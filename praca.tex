
\input{./defs/WAT-WCY-1.0.tex}
\newcommand{\kierunek}{INFORMATYKA}
\newcommand{\stopien}{STUDIA II$^{\mathrm{o}}$} %Odpowiednie usunąć
\newcommand{\temat}{MOBILNY SYSTEM ZARZĄDZANIA I STEROWANIA BEZPILOTOWYM STATKIEM LATAJĄCYM}
\newcommand{\data}{Warszawa 2022}
\newcommand{\autor}{sierż.~pchor.~inż.~Norbert~WASZKOWIAK}
\newcommand{\promotor}{dr inż. Michał DYK}
\newcommand{\zgoda}{TAK} %W przypadku braku zgody zakomentować tą linię
\newcommand{\specjalnosc}{SYSTEMY INFORMATYCZNE}

\newcommand{\bibTitle}[1]{``#1''}


\begin{document}

\inserttitlepage

\section*{Wstęp} 
\addcontentsline{toc}{section}{Wstęp}


Obecne lata są okresem dynamicznego rozwoju bezpilotowych statków powietrznych. Rozwój ten obejmuje zarówno rynek cywilny, jak i militarny. W obecnym, 2022 r. można dostrzec ich szczególną rolę w konflikcie militarnym między Rosją oraz Ukrainą. Jego analiza pozwala wnioskować, że w przyszłości liczba i znaczenia bezpilotowych statków powietrznych wykorzystywanych przez armie na świecie będzie rosła.

Czynnikiem wstrzymującym ich rozwój jest liczba operatorów. Aktualnie jeden operator jest w stanie kontrolować wyłącznie jeden bezpilotowy statek powietrzny. Jest to szczególnie ograniczające, szczególnie gdy obecnie najcenniejszym zasobem w armii jest dobrze wyszkolony żołnierz, którego pozyskanie, w porównaniu do sprzętu wojskowego jest dużo trudniejsze.

Rozwiązaniem takiego problemu jest wprowadzenie rozwiązań umożliwiających jednoczesną kontrolę wielu bezpilotowych statków powietrznych. Jest ono określane jako „rój dronów". Na dalekim zachodzie już podjęto kroki, które sprawią, że taki rój stanie się jak najbardziej realny. 24 lutego 2022r. armia amerykańska podpisała z firmą BlueHalo kontrakt na 14 mln dolarów, który dotyczy właśnie opracowania takiego rozwiązania w ciągu następnych 30 miesięcy. \cite{usa-roj}

Rozwiązania, które są wykorzystywane w armii, często przenoszone są na rynek cywilny. Autor tej pracy uważa, że to samo będzie dotyczyło wykorzystywania roju dronów.

Zrealizowanie całego systemu do zarządzania rojem znacznie wykracza poza obszar możliwy do zrealizowania w ramach pracy dyplomowej. Zostanie więc ona ograniczona do elementu odpowiedzialnego za komunikacje między dronem a centralnym punktem odpowiedzialnym za ich kontrole. Rozwiązanie to ma być przede wszystkim skalowane w poziomie, tzn. musi ono umożliwiać sterowanie kolejnymi bezpilotowymi statkami powietrznymi za pomocą jednego i tego samego punktu kontrolującego, którego fizyczne umiejscowienie nie powinno być w żaden sposób ograniczone względem lokalizacji dronów.

Postawione zadanie zostanie zrealizowane w następujących rozdziałach:
\begin{itemize}
  \item Rozdział 1: Prezentacja zagadnienia bezpilotowych statków latających oraz koncepcji ich wykorzystania
  \item Rozdział 2: Przegląd i prezentacja technologii mobilnych z uwzględnieniem aspektów tworzenia aplikacji i komunikacji M2M
  \item Rozdział 3: Projekt mobilnego systemu zarządzania i sterowania BSP
  \item Rozdział 4: Implementacja systemu
  \item Rozdział 5: Testy systemu oraz prezentacja użycia na wybranym case study
\end{itemize}

Celem pierwszych dwóch rozdziałów jest przedstawienie dziedziny obszaru, którego dotyczy rozwiązanie. W pierwszym z nich zdefiniowano bezpilotowy statek powietrzny. Na podstawie tej definicji przeanalizowano i zaprezentowano jego historię. Rozdział kończy przedstawienie rozwiązań i zastosowań bezpilotowych statków powietrznych na rynku cywilnym i militarnym. W drugim rozdziale zdefiniowano komunikację M2M (\textit{Machine to Machine}) i przedstawiono jej najpopularniejsze rozwiązania, wraz ze szczególnym uwzględnieniem komunikacji między bezpilotowym statkiem powietrznym a kontrolerem.

Trzy pozostałe rozdziały dotyczą przedstawienia rozwiązania na zdefiniowany wcześniej problem. W trzecim rozdziale zdefiniowano wymagania stawiane systemowi. Następnie omówiono i uzasadniono wybrany stos technologiczny, po czym  zaprezentowano trzy rodzaje diagramów opisujących system: architektury wysokopoziomowej, komponentów i klas. Na koniec przedstawiono środowisko uruchomieniowe. Czwarty rozdział przedstawia implementacje najważniejszym elementów systemu m.in. obsługi komunikacji poprzez serwer MQTT. W ostatnim rozdziale zaprezentowano szereg testów, które świadczą o poprawnym działaniu całego systemu.



    
% Zwarte wprowadzenie w temat i cele pracy z nawiązaniem do dziedziny przedmiotowej oraz rozwiązanego problemu. Uzasadnienie potrzeby i zastosowania wyników pracy. Przedstawienie układu i streszczenie zawartości rozdziałów pracy (2-3 zdania na rozdział).\\
% Zaleca się, aby tekst wstępu nie przekraczał dwóch stron.


% W pierwszym rozdziale przedstawiono definicje BSP. Następnie przyjrzano sie jej historii z uwzględnieniem tego kiedy obiekt może być zakwalifikowny jako BSP. Potem przedstawiono czołowych producntów tej technolgii i przykładowe zastosowania. Rozdział zakończono analizą możliwości dostoswywania statków do wymagań użytkownika.
\clearpage

\newpage
\section{Prezentacja zagadnienia bezpilotowych statków latających oraz koncepcji ich wykorzystania}
\subsection{Definicja BSP}
W nomenklaturze związanej z domeną bezpilotowych statków latających można znaleźć wiele tożsamych terminów na określanie bezpilotowych statków latających, są to m.in.:
\begin{itemize}
  \setlength\itemsep{1mm} %TODO
  \item Bezzałogowy statek powietrzny, BSP (ang. \textit{unmanned aerial vehicle}, UAV);
  \item Bezzałogowy system powietrzny (ang. \textit{unmanned aerial system}, UAS);
  \item Samolot zdalnie sterowany (ang. \textit{remotely piloted aircraft}, RPA);
  \item Dron (ang. \textit{drone}),
\end{itemize}

Każdy z tych terminów kładzie nacisk na inną cechę, ale wszystkie nadal odnoszą się do jednego obiektu i będą w tej pracy używane zamiennie. 

Amerykański pisarz zajmujący się zagadnieniami systemów bezzałogowych i technologi obronnych,  Kelsey Artheon na łamach czasopisma \textit{Popular Science} definiuje to pojęcie następująco: "dron oznacza każdy bezzałogowy zdalnie sterowany pojazd latający, bez względu na to, czy jest to malutki, sterowany radiem helikopter-zabawka, czy też ważący 14,5 tony Global Hawk, wart 104 mln dolarów. Jeżeli coś lata i jest sterowane przez pilota z ziemi, to pasuje do potocznej definicji drona". \footnote{A. Kelsey, \textit{Flying Robots 101: Everthing You Need to Know about Drones}, Popular Science\cite{arton-kelsey}} Biorąc to pod uwagę, można zdefiniować następujące warunki do zakwalifikowania obiektu jako bezzałogowy statek powietrzny:
\begin{itemize}
  \item \textbf{bezpilotowość} - na swoim pokładzie nie posiada pilota;
  \item \textbf{dwukierunkowość} - musi mieć możliwość powrotu/wylądowania (Jest to podstawowa cecha odróżniająca drony od pocisków manewrujących); 
  \item \textbf{sterowalność} - możliwość zmiany kierunku lotu w trakcie jego wykonywania.\\\cite{dron-ibuk}\cite{arton-kelsey}
\end{itemize}

\subsection{Historia BSP}
Po przedstawieniu definicji BSP można przystąpić do przedstawienia historii całej tej domeny, wraz ze wskazaniem jej początku w poprawny sposób.

\subsubsection{Błędnie klasyfikowane obiekty}
Po zdefiniowaniu czym jest dron, można się zastanowić, co było pierwszym elementem spełniającym tę definicję. Autor tej pracy uważa, że kluczowym elementem umożliwiającym zakwalifikowanie obiektu jako dron jest możliwość zmiany trajektorii lotu w trakcie jego działania. W literaturze często wskazywane są dwa obiekty jako prekursory dronów, tzn. gołąb Archytasa z Tarentu i balony zawierające ładunki wybuchowe wykorzystane w konflikcie między Austrią i Wenecją w 1849 r. Pierwszy rzekomy prekursor nie umożliwia sterowania obiektem po jego wystartowaniu, więc tym samym nie jest to zgodne z przytoczonymi definicjami. Ten wynalazek można uznać za pierwszą rakietę lub robota, ale nie drona. Drugi przykład, czyli balony na gorące powietrze, również nie mogą zostać uznane za bezzałogowy statek powietrzny z tego samego powodu. Jako ciekawostkę można dodać, że pomysł Austriaków zakończył się niepowodzeniem, ponieważ wiatr zwiał balony na ich własne pozycje.\cite{dron-ibuk}. 


\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=8cm]{./Obrazy/golab.jpg}
  \caption{Latający gołąb Archytasa z Tarentu}
\end{center}
\source{\myurl{https://input.niezalezna.pl//259fef5fd.jpg}}
\end{figure}

\subsubsection{Pierwszy pełnoprawny dron}
Podczas I wojny światowej podjęto liczne próby skonstruowania bezpilotowych statków latających, ale żaden z nich nie został ukończony przed skończeniem wojny. Przykładowo \textit{Kettering Bug}, był w stanie dolecieć na odpowiednią odległość, ale jego sterowanie polegało na wyliczeniu przez operatora dokładną liczbę obrotów silnika. Mając to na uwadze, takiemu samolotowi bliżej do torpedy niż do drona. 

\begin{figure}[ht!]
\begin{center}
  \includegraphics[width=10cm]{./Obrazy/queen-bee.jpg}
  \caption{\textit{De Havilland Queen Bee} i premier Wielkiej Brytanii Winston Churchill}
\end{center}
  \source{\myurl{https://www.iwm.org.uk/collections/item/object/205195356}}
\end{figure}

W 1931 r. Królewskie Siły Powietrzne (ang. Royal Air Force) na podstawie samolotu szkolnego \textit{De Havilland DH-60T ”Tiger Moth”} opracowywały pierwszy bezpilotowy statek powietrzny \textit{DH-82B "Queen Bee"}.  Samolot ten, sterowany przez pilota za pomocą fal radiowych, miał służyć jako ruchomy cel do ćwiczeń dla obsługi dział przeciw lotniczych. Jego oficjalna prezentacja została jednak przerwana, ponieważ ówczesne systemy obrony powietrznej były tak mało skuteczne, że strzelającym skończyła się amunicja, zanim zestrzelili oni bezpilotowy samolot. Obiekt ten też spełnia wszystkie wymagania określone wcześniej przez autora, więc uznaje on go za pierwszego drona.

Równolegle w tym samym okresie, a konkretnie w 1935 r. powstał identyczny samolot dla amerykańskich odbiorców, \textit{Radioplane OQ-2}. Powstał on jako pierwotnie jako bezzałogowiec, a nie przez modyfikacje tak jak dron brytyjski, więc jego budowa bardziej odstawała od klasycznych samolotów.\cite{queen-bee}\cite{dron-ibuk}

\subsubsection{Pierwsze drony rozpoznawcze}
W bezpośrednim okresie po II wojnie światowej USA kontynuowało prace nad dronami, poprzez firmę \textit{Ryan Aeronautical Company} i ich serii dronów \textit{Firebee}, produkowanych od 1951 r. Efektem tej serii był m.in. opracowany w 1962 r. \textit{Ryan Model 147 Lightning Bug}. Był to dron rozpoznawczy, napędzany był za pomocą silnika rakietowego. Nie posiadał on wyposażenie do lądowania i startowania z ziemi, tak więc odbywała się to za pomocą spadochronu, w który był wyposażony, i jego przechwyceniu w locie przez helikopter. Sam start odbywał się z pokładu samolotu. Tak samo, jak pociski rakietowe, dron ten był umieszczany pod skrzydłem samolotu.

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=10cm]{./Obrazy/Model_147_RPV.png}
  \caption{\textit{Ryan Model 147 Lightning Bug} umieszczony pod skrzydłem samolotu transportowego}
\end{center}
\source{\myurl{https://en.wikipedia.org/wiki/
File:Model_147_RPV_pictured_in_flight_under_wing_pylon_of_a_carrier_aircraft.png}}
\end{figure}

\subsubsection{Ikona wśród BSP}
Zdecydowanie do najpopularniejszego BSP na świecie należy zaliczyć, produkowanego przez amerykańskiego producenta, \textit{General Atomics} \textit{MQ-1 Predator}. Pierwsze jego wersje nie posiadały na swoim pokładzie żadnych pocisków, ponieważ rząd USA nie byli pewni czy jest to zgodne z obowiązującym układem dotyczącym całkowitej likwidacji pocisków rakietowych średniego zasięgu (ang. \textit{Intemediate-range Nuclear Forces (INF) Traty}). Jednak wydarzenia z 11 września 2001 r. były impulsem do podjęcia decyzja o uzbrojeniu Predatorów w pociski rakietowe i skierowania ich do akcji. Umożliwiło to prowadzenie operacji militarnych bez ponoszenia strat w żołnierzach. Drony te były wykorzystywane w trakcie konfliktów w Afganistanie, Iraku czy Pakistanie. Na przestrzeni lat 2009-2021 Zjednoczona Ameryka stała się światowym liderem w używaniu dronów bojowych.\cite{dron-ibuk}\cite{predator-wiki} 


\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=10cm]{./Obrazy/predator.jpg}
  \caption{\textit{MQ-1 Predator}, wyposażony w rakiety \textit{AGM-114 Hellfire}}
\end{center}
  \source{\myurl{https://en.wikipedia.org/wiki/File:MQ-1_Predator,_armed_with_AGM-114_Hellfire_missiles.jpg}}
\end{figure}

\subsubsection{Drony cywilne}
Trudno zaprzeczyć stwierdzeniu, że wojna przyczynia się do szybszego rozwoju, bo to właśnie rozwiązania opracowane dla armii przenoszone są często do życia codziennego. Było tak z herbatą ekspresową, jak jest i teraz z bezzałogowymi statkami powietrznym. Zmieniła się tylko ich rola, za ich pomocą nie prowadzi się działań wojennych, a nagrywa sceny do filmów, prowadzi transmisje skoków narciarskich z ciekawszej perspektywy i ratuje ludzi zagubionych w górach. Okolice obecnego roku można wskazywać jako okres największego zainteresowania tą technologią na rynku cywilnym. Początku tego okresu można próbować określać na 2013 r., czyli datę premiery pierwszej wersji, prawdopodobnie najpopularniejszej serii dronów \textit{Phantom} od obecnie najpopularniejszego producenta dronów konsumenckich \textit{DJI}.

\subsubsection{Konfilikt na Ukrainie}
W kontekście bezzałogowych statków powietrznych nie można pominąć aktualnego konfliktu zbrojnego na Ukrainie. Należy go rozpatrywać w dwóch aspektach: przewagi, która armia ukraińska uzyskuje dzięki tureckim dronom \textit{Bayraktar TB2} i wykorzystaniu dronów konsumenckich od ludności cywilnej do przeprowadzenia rozpoznania powietrznego.

Rząd ukraiński zwrócił się z prośbą do swoich obywateli o przekazanie swoich dronów na potrzeby armii. Są one wykorzystywane do bezpiecznego prowadzenie rozpoznania przez wojska ukraińskie. Dostarczają one obraz na żywo, wraz ze swoimi współrzędnymi geograficznymi. Pozwala to budować przewagę informacyjną na polu bitwy, a ten konflikt szczególnie uświadomił, jak ważna jest dzisiaj informacja na polu bitwy.\cite{fotografia-drony-ukraina}

Czytając artykuły poświęcone dronom \textit{Bayraktar TB2} w kontekście konfliktu, mo-\\żna odnieść wrażenie, jakby było to jedyny element budujący ich siłę. Autor nie może się z tym zgodzić, ale nie da się zaprzeczyć, że ich rola jest znacząca. Szczególnie po obejrzeniu licznych nagrań dostępnych w internecie z działań tych samolotów na wojnie. Głównym celem tej maszyny jest jednak prowadzenie rozpoznania, ale mogą być one doposażone w cztery pociski kierowane o zasięgu 8 km. Sam dron jest jedną z tańszych opcji na ryku, bo jego cena wacha się między 2-6 mln dolarów, a drony z najwyższej półki sięgają 100 mln dolarów. Rozpiętość skrzydeł tego drona to 12 metrów, a długość to 6,5 metra, co przekłada się na możliwość szybowania przez 27 godzin lub przelecenia 150 km. W dodatku wzbija się na pułap 8200 m i rozwija prędkość do 220 km/h, a wszytko to za sprawą silnika \textit{Rotax 912 iS} o mocy 100 koni mechanicznych.\cite{bayraktar-chip}\cite{bayraktar-pap}

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=12cm]{./Obrazy/Bayraktar_TB2_ukraina.jpg}
  \caption{Bayraktar TB2}
  \end{center}
  \source{\myurl{https://www.instalki.pl/images/newsy/03-2022/Bayraktar_TB2_ukraina.jpg}}
\end{figure}


\subsection{Technologia i producenci BSP}
Wymagania stawiane dronom na rynku cywilnym i militarnym znacznie się od siebie różnią, tak samo, jak konstrukcje które je spełniają. Największą różnicą jest właśnie rozmiar. Militarne BSP do realizacji swoich zadań muszą pokonywać dużo większe dystanse, przewożąc przy tym ciężkie wyposażenie. Te dwa środowiska można też uznać za hermetyczne względem siebie, rzadko następuje przejście z jedno w drugie. Większość producentów dronów wojskowych wcześniej produkowała inny sprzęt wojskowy, a cywilnych kamery czy elektryczne szybowce.

\subsubsection{Shenzhen DJI Sciences and Technologies Ltd.}
Shenzhen DJI Sciences and Technologies Ltd., znany powszechnie pod nazwą handlową DJI, jest obecnie największym producentem dronów konsumenckich. Z siedzibą w chińskiej "dolinie krzemowej" Shenzhen. Firma została założona w 2006 r., a swój pierwszy sukces odniosła w 2013 r. kiedy wpuściła na rynek pierwszy model seri dronów \textit{Phantom}. Był to BSP przeznaczony dla początkujących operatorów, a na tle konkurencji wyróżniała go łatwość obsługi. W kolejnych latach firma kontynuowała swój rozwój, a w 2015 r. wraz z wypuszczeniem trzeciej wersji jego wersji stała się ona największym producentem na świecie. W 2016 r. firma ta posiadała 50\% udziałów w światowym rynku, a rok później już 72\%. W 2020 r. było około 74\%, podczas gdy żadna inna firma w tym samym czasie nie posiadała więcej niż 5\% udziału w światowym rynku.

W 2020 r. BSP firmy DJI były wykorzystane przez Chiny do przypominania ludziom o obowiązku noszenia maseczek na twarzy w celu ograniczenia rozprzestrzeniania sie wirusa COVID-19. Z tego samego powodu w takich krajach jak Maroko czy Arabia Scytyjską drony mierzyły temperatury przemieszczającej się populacji w terenach silnie zurbanizowanych.\cite{dji-wiki}\cite{dji-market-share}

\subsubsection{Yuneec International}

Yuneec International to drugi co do wielkości producent dronów konsumenckich, pomimo że w rynku światowym posiada zaledwie 5\% udziałów. Firma ta została założona w 1999 r. i pierwotnie zajmowała się produkcją samolotów elektrycznych i szybowców. Obecnie jej siedziba znajduje się w Jiangsu w Chinach. Do swojej oferty wprowadziła pierwszego drona w 2015 r. Był on przeznaczony do fotografii. 

W 2014 r. firma została członkiem założycielem \textit{Dronecode}, organizacji non-profit prowadzonej przez \textit{Linux Foundation}, której celem jest dostarczanie otwartego oprogramowania do dronów opartego na jądrze systemu Linux. Firma \textit{Intel Corpoartion} w sierpniu 2015 r. zainwestowała 60 mln dolarów w Yuneec w zamian za 15\% udziałów. Celem inwestycji była wspólna realizacja przyszłych projektów. W tym samym miesiącu Yuneec wprowadził na rynek drona \textit{Breeze}, zdolnego do rejestrowania filmów i zdjęć w rozdzielczości UltraHD 4K. 

Również w 2015 r. firma nawiązała współprace z Ocean Alliance, organizacją zajmującą się ochroną wielorybów. Celem było stworzenie bezpieczniejszego sposobu na zbieranie danych o stanie zdrowia wielorybów. Organziacja Ocean Alliance, zamiast korzystać, tak jak dotychczas z rzutek biopsyjnych zaczęła używać do tego celów specjalnie wyposażonych dronów Yeneec.\cite{yuneec-wiki}

\subsubsection{Baykar}

W tym zestawieniu nie mogło zabraknąć producenta najpopularniejszego drona militarnego w kontekście aktualnego konfliktu zbrojnego na Ukrainie, czyli: \textit{Baykar}. Jest to prywatna firma Turecka specjalizująca się w obszarach sztucznej inteligencji, BSP i systemach \textit{Command And Control} (pl. dowodzenie i kontrola). Została ona założona w 1984 r. przez Özdemir Bayraktar i pierwotnie dostarczała części samochodowe takie jak pompy, silniki i inne. W latach dwutysięcznych firma zainteresowała się obszarem BSP, czego efektem było wyprodukowanie \textit{Bayraktar Mini UAV}. Był to pierwszy dron w całości wyprodukowany z kapitału krajowego Turcji i w 2007 r. znalazł się na wyposażeniu Tureckich Sił Zbrojnych. Rozpoczęcie prac badawczo-rozwojowych przyczyniło się do produkcji pionierskich i zaawansowanych systemów. Portfolio firmy obejmuje również latający samochód, nazwany \textit{Cezeri}, który w trakcie testów w Stambule we wrześniu 2020 r. Wzniósł się na wysokość 10 m.\cite{baykar-wiki}

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=12cm]{./Obrazy/cezarei.jpg}
  \caption{Dron osobowy Cezarei w trakcie testów w Stambule}
\end{center}
\source{\myurl{https://www.savunmahaber.com/en/wp-content/uploads/2020/09/CEZERI-UCAN-ARABA-26.jpg}}
\end{figure}

\subsubsection{General Atomics}
\textit{General Dynamics Corporation} to amerykańska korporacja założona w 1952 r., z siedzibą w Reston, w stanie Wirginia. Do 1990 r. dostarczała on czołgi, rakiety, pociski, łodzie podwodne, okręty wojenne, myśliwce i elektronikę dla wszystkich rodzajów wojsk. Na początku lat 90tych sprzedała całe swoje portfolio, z wyjątkiem działalności związanej z pojazdami wojskowymi i okrętami podwodnymi.

Korporacja ta jest właścicielem \textit{General Atomics Aeronautical Systems}, która zajmuje się produkcją systemów radiowych i bezzałogowych statków powietrznych, w tym rewolucyjnego kiedyś drona wojskowego \textit{Predator}. Seria tych dronów jest nadal rozwijana, a poszczególne konstrukcje są do siebie bardzo zbliżone.\cite{gd-about}\cite{wiki-gaas}

\subsection{Zastosowania BSP}
Bezpilotowe statki latające znalazły szereg zastosowań, pierwotnie były wykorzystywane głównie w obszarze militarnym, dopiero później dostrzeżono w nich potencjał również w środowisku cywilnym. Ponieważ kontekst militarny został już dość szczegółowo przedstawiony, w poniższym tekście przyłożono większą uwagę do ich cywilnych zastosowań.

\subsubsection{Militarne zastosowania BSP}
Bezzałogowe statki powietrzne w kontekście militarnym można dokonać podziału na następujące kategorie: 
\begin{itemize}
  \item \textbf{bojowe} - przenoszące i używające środki bojowe/ środki rażenia, np. \textit{Bayraktar TB2};
  \item \textbf{amunicja krążąca} - umożliwiające wykrywanie, rozpoznanie oraz atak na wyznaczony cel poprzez autodestrukcje, np. \textit{WB Electronics Warmate};
  \item \textbf{operacyjno-rozpoznawcze} - realizjące rozpoznawanie oraz śledzenie \\obiektu/celu, a także monitorowanie i kontrole obszaru zainteresowania, np. granic lub strefy przybrzeżnej. Przykładem takiego drona jest \textit{Lockheed Martin RQ-170 Sentinel};
  \item \textbf{wsparcia}: umożliwiające ewakuacje lub dostawę amunicji, wyposażenia, środków medycznych i żywności do wysuniętych stanowisk wojsk własnych, np. \textit{Kaman KARGO UAV} \cite{konkurs-mon}
\end{itemize}

\subsubsection{Cywilne zastosowania BSP}
Wymienienie wszystkich cywilnych rozwiązań jest trudne, ponieważ rynek ten znajduje co chwilę kolejne zastosowania dronów. Poniżej przedstawiono parę wyselekcjonowanych interesujących rozwiązań.

\myparagraph{Transport medyczny}
W czerwcu 2022 r. Polska Agencja Żeglugi Powietrznej wydała zgodę na wykonywanie regularnych długodystansowych lotów BSP. Realizować będzie je firma transportowa na rzecz systemu opieki zdrowotnej. Połączenie obejmie dwie trasy Warszawa-Pułtusk i Warszawa-Sochaczew. Przewidywana częstotliwość lotów to ok. 7 w tą i z powrotem w ciągu dnia. Obie te trasy mają długość 60 km i odbywają się na wysokości 100 m. Sam samolot posiada systemy wizyjne, które będą korygowały lot w przypadku wystąpienia przeszkód na jego trasie przelotu. Takie połączenie zapewni szybki transport np. narządów do przeszczepu co może przyczynić się do uratowania komuś życia. \cite{pansa-lot-medyczny}

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=10cm]{./Obrazy/Farada_G1.jpg}
  \caption{Dron \textit{Farada G1}, za pomocą którego będzie obywał się transport medyczny w okolicach Warszawy}
\end{center}
  \source{\myurl{https://www.pansa.pl/wp-content/uploads/2022/02/IMG-20220213-WA0001-1024x577.jpg}}
\end{figure}

\myparagraph{Ratownictwo}
Drony powietrzne pomagają również w ratowaniu ludzkiego życia, szczególnie w górach. W styczniu 2022 r. ze względu na trudne warunki atmosferyczne ratownicy TOPR nie mogli udzielić pomocy dwóm turystą, którzy nie byli w stanie zejść z góry. Za pomocą drona dostarczono im koce i ogrzewacze, co pozwoliło im przetrwać noc. Kolejnego dnia, gdy pogoda uległa poprawie ratownicy dotarli do poszkodowanych i ich sprowadzili w bezpieczny sposób.\cite{topr-dron}

Również na dalekim zachodzie można znaleźć przykłady ratowania życia z użyciem BSP, a konkretnie w Północnej Kalifornii. Właśnie tam, w lesie, zgubił się młody myśliwy. Służby za pomocą drona zlokalizowali jego lokalizacje, a następnie wysłali tam strażników, którzy z jego pomocą wyprowadzili zagubionego.\cite{bbc-drone-rescue} 

Są cztery powody, dla którego BSP dobrze odnajdują się w ratownictwie.
\begin{itemize}
  \item \textbf{Czas reakcji} - są opcją bardzo szybkiego reagowania, czas potrzebny na przygotowania do startu jest minimalny;
  \item \textbf{Szybkie przeszukiwania} - mogą przeszukac trudny teren w dużo szybszym czasie niż człowiek pieszo;
  \item \textbf{Komunikacja} - mogą koumunikować sie z poszkodowanymi za pomocą głosnika i mikrofonu;
  \item \textbf{Lokalizacja} - są w stanie przekazywać na żywo do operatora swoją aktualną lokalzacje, co w przypadku ratowania i poszukiwania osób może znacznie minimalizować czas poszukiwania i ewakuacji. \cite{snowbrains-drone}
\end{itemize}

\myparagraph{Kinematografia i produkcja filmowa}
Jednym z pierwszych filmów, które przywoływane jako przykład dobrego wykorzystania dronów jest \textit{Skyfall} z 2012 r., a konkretnie scena pościgu motorem przez Jamesa Bonda złoczyńców po dachach w Istambule. BSP dały kinematografii wyjątkową przewagę nad tradycyjnymi metodami filmowania. Mają większy zasięg niż żuraw i są też bardziej zwinne niż helikopter. Reżyserzy dzięki temu mogą wykonywać bardziej ryzykowne, prawdziwie akrobatyczne ujęcia, które gdyby nie drony musiałyby być wytworzone na komputerze. Nie można zapomnieć, że BSP są przede wszystkim tańsze w zakupie i utrzymaniu niż np. helikoptery.\cite{washingtonpost-drone-movie}

Przykładem gdzie wcześniej nie było możliwe nagrywanie ujęć filmowych, są erupcje wulkanów. Takie loty wiązały się z dużym niebezpieczeństwem, a drony są dużo tańsze i nie posiadają na swoim pokładzie załogi, tak więc operatorzy mogą pokusić się o takie ryzyko. Takie nagranie wykonał znany youtuber Joey Helms, który postanowił uwiecznić z bliska rzekę lawy wyrzucaną przez wulkan Fagradalsfjall na Islandii. W trakcie nagrywania erupcja lewy w pewnym momencie sięgnęła jego statku. Youtuber bezpowrotnie stracił swój statek. Ujęcie, które zostało zachowane, jest bardzo emocjonujące, więc prawdopodobnie było to warte swojej ceny.\cite{dron-lawa-pogoda}

\myparagraph{Transport towarów}

W 2013 r. Jeff Bezos ogłosił koncepcje, która miała zrewolucjonizować transport towarów. Autonomiczne drony powietrzne miały dostarczać paczki Amazonu w 30 minut pod drzwi odbiorcy. Mogły one zaoferować konsumentom dostawę żywności, leków czy innych lżejszych przedmiotów, bez spalania paliw kopalnianych i czekania. Niestety jednemu z najbogatszych ludzi na świecie nie udało się tego osiągnąć. Tak samo, jak firmie \textit{Zipline}, która miała dostarczać leki w Rwandzie i projektowi Google \textit{Wing}, który miał zapewniać burito głodnym studentom. Na świecie istnieje duża presja na wprowadzenie takiego rozwiązania. W 2021 r. Amazon zwolnił większość pracowników odpowiedzialnych za rozwój wspominanego projektu, uzasadnił to błędem w zarządzaniu i panującym chaosem. W tym samym roku DHL również ogłosił zakończenie swojego identycznego projekty. Było to 8 lat po tym, gdy ich dron pierwszy raz wbił się w powietrze.Koszty transportu towaru między centrum dystrybucji a klientem końcowym to 40\% całkowitego kosztu, a konsumenci oczekują szybkiej taniej i ekologicznej dostawy. Wszystkie te potrzeby mogłyby zaspokoić dostawy dronami.

Jest parę czynników, które mogły wpłynąć na wstrzymanie masowych dostaw towarów dronami. Głownym z nich jest prawodopodobnie ograniczenie stref lotów BSP. Osoby zarządzające państwami i miastami na bieżąco wprowadzają regulacje w tej dynamicznie rozwijającej sie domenie. Wprowadzone zostały m.in. sterefy wyłączone dla dronów, które mają zapewnić bezpieczeństwo wokół miejsc wymagających specjalnej ochorny. Są to najczęściej okolice lotnisk i jednostek wojskowych. Takie strefy mocno ograniczają dostawy towarów dronami.\cite{drone-transport}


\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=16cm]{./Obrazy/no2.png}
  \caption{Strefy wyłączone dla dronów w okolicach Warszawy}
  \source{\myurl{https://www.dji.com/pl/flysafe/geo-map}}
\end{center}
\end{figure}

Mimo wszystko taki transport jest jednak nadal możliwy, ale nie na masową skalę. W Sosnowcu od 2021 r. realizowany jest projekt, w którym drony będą świadczyły usługi transportu m.in. pilnych przesyłek medycznych. Odbiór i nadawanie będzie odbywało się w stacjach dokujących, które będą automatycznie ładowały i zdejmowały ładunek z drona. Wykorzystanie takich punktów umożliwia ustawienie stałej trasy lotów, co zdejmuje duża część odpowiedzialności z uczestników projektu, dlatego też w przyszłości można spodziewać się większej ilości tego typu rozwiązań.\cite{sosnowiec-drone}


\subsection{Dostosowywanie BSP do wymagań użytkownika}
Na rynku znajduje się duża ilość dostępnych komponentów, z których można łatwo zbudować własne bezzałogowe statki powietrzne. Najwięcej odpowiedzialności z konstruktora zdejmują gotowe kontrolery lotu, np. \textit{pixhawk}, na którym można zainstalować otwarte oprogramowanie \textit{ArduPilot}. Pozwala to zachować duża ilość zasobów, bo cała logika lotu jest praktycznie \textit{out-of-the-box} Przykładowy zestaw elementów potrzebnych do zbudowania własnego drona to::
\begin{itemize}
  \setlength\itemsep{1mm} %TODO
  \item rama,
  \item silnik,
  \item elektroniczny kontroler prędkości,
  \item śmigła,
  \item załącza,
  \item rozdzielnia zasilająca,
  \item baterie,
  \item monitoring baterii,
  \item mata montażowa,
  \item kontroler,
  \item odbiornik RC,
  \item kamera,
  \item karata pamięci SD.\cite{how-to-build-drone}
\end{itemize}

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=12cm]{./Obrazy/pixhawk.png}
  \caption{Kontroler lotu Pixhawk}
  \end{center}
  \source{\myurl{https://ardupilot.org/plane/_images/Pixhawk_with_legend.jpg}}
\end{figure}

Budowa własnego drona jest jak najbardziej możliwa, bez wymagania specjalistycznej wiedzy, ale nadal to potrzeba na to dużo ilości zasobów, szczególnie czasu, dlatego warto przyjrzeć się gotowym rozwiązaniom dostarczanym przez producentów i to jak bardzo można je dostosowywać. Firma DJI udostępnia do swoich produktów SDK, czyli bibliotekę, za pomocą której można zaprogramować działanie naszego drona. Dodatkowo producent dla wybranych statków przygotował szereg rozszerzeń, które pomogą dostosować wyposażenie do naszych wymagań. Przykładowo dla \textit{Mavic 2 Enterprise Advaced} dostępne są:
\begin{itemize}
  \item \textbf{głośnik} - który umożliwia komunikacje z drona, np. w czasie sytuacji alarmowych do ludności znajdującej sie na ziemi
  \item \textbf{dodatkowe oświetlenie} - w przypadku wystąpienie niekorzystnych warunków atmosferycznych lub lotów w nocy
  \item \textbf{moduł RTK} - który umożliwia osiągnięcie dokładności lokalizacji na poziomie jednego centymetra
\end{itemize}
Dodatkowo dla innych modeli dostępne są wyspecjalizowane kamery np. do skanu obiektów w 3D czy podglądu w podczerwieni.

\newpage 
\section{Przegląd i prezentacja technologii mobilnych z uwzględnieniem aspektów tworzenia aplikacji i komunikacji M2M}
W tym zdefiniowano cel i wymagania stawiane technologią M2M. Następnie przedstaw przedstawiono przykładowe technologie ze szczególnym uwzględnieniem komunikacji pomiędzy bezzałogowym statkiem powietrznym a kontrolerem. Rozdział zakończono analizą interfejsu API umożliwiającego kontrolowanie drona.

\subsection{Komunikacja M2M}
Komunikacja M2M (machine-to-machine) to kategoria technologii, która umożliwia wymianę informacje pomiędzy urządzeniami w sieci bez jakikolwiek ingerencji ludzi. Obiekty pracujące w tej sieci charakteryzują się mniejszą lub większą autonomią. Wspierana jest ona często szeroko pojętą sztuczną inteligencją, ze szczególnym uwzględnieniem technik uczenia maszynowego. Ta komunikacja jest podstawą istnienia IoT.\cite{m2m-web}

\subsubsection{Cel}
Głównym celem M2M jest autonomiczna komunikacji pomiędzy maszynami, a jej obecnie najczęstszym zastosowaniem jest przenoszenie danych z sensorów do sieci. Obecnie operatorzy coraz częściej rozbudowują swoją infrastrukturę o węzły zgodnie z tą kategorią technologii. Dzięki temu koszty utrzymania całego systemu są znacznie zredukowane. Składają się na niego następujące elementy:
\begin{itemize}
  \item łącze do przesyłu danych, np. WiFi, GSM
  \item sensory, np. czujnik temperatury, kamera
  \item oprogramowanie, które automatyzuje procesy komunikacyjne, np. przeszukiwanie ścieżki routingu
\end{itemize}
Celem telemetrii jest automatyczny pomiar wielkości fizycznej przez odpowiednie sensory. Wartość pomiaru jest przesyłana do miejsca, zwykle odległego, w którym jest dalej przetwarzana. Na początku do tego celu były wykorzystywane linie telefoniczne, a następnie radiowe. Rozwój technologii, a w tym łączności bezprzewodowej sprawił, że poszerzyła się rola wykorzystywania telemetrii w nauce, inżynierii i produkcji. Dzisiaj jest ona używana także w życiu codziennym, w jednostkach grzewczych, miernikach elektrycznych i wszelkich urządzeń podłączonych do internetu. Jej rozwój jest ściśle powiązany z komunikacją M2M.\cite{m2m-web}

\subsubsection{Wymagania}
Według Europejskiego Instytutu Norm Telekomunikacyjnych (ETSI) komunikacja \\M2M musi spełniać następujące wymagania:
\begin{itemize}
  \item \textbf{Skalowalność}: w miarę dołączania kolejnych urządzeń do systemu system nadal musi funkcjonować;
  \item \textbf{Anonimowość}: w związku z wymaganiami prawnymi, na każde żądanie system musi umożliwiać ukrywanie tożsamości urządzenia;
  \item \textbf{Logowanie}: ważne wydarzenia w systemie, takie jak: pojawienie się błędnych informacji czy nieudane próby instalacji, muszą być zarejestrowane, a rejestry te muszą być dostępne na żądanie;
  \item \textbf{Zasady komunikacji między aplikacjami}: aplikacje w systemie powinny mieć możliwość komunikowania się. W szczególności bramki i urządzenia końcowe komunikujące się za pomocą technologi SMS czy Ethernet powinny komunikować się za pomocą połączenia P2P (peer-to-peer);
  \item \textbf{Metody dystrybucji}: w ramach systemu powinny być dostarczane metody dystrybucji takie jak: \emph{unicast}, \emph{multicast}, \emph{broadcast} i \emph{annycast}, a wszędzie gdzie to możliwe metoda \emph{broadcast} powinna być zastąpiona za pomocą \emph{multicast}, tak aby zminimalizować obciążenie sieci;
  \item \textbf{Harmonogram przesyłania komunikatów}: dostęp do sieci powinien być kontrolowany, tak samo, jak harmonogram przesyłania komunikatów. Sam system powinien również uwzględniać obciążenia aplikacji M2M w harmonogramie przesyłania wiadomości;
  \item \textbf{Wybór ścieżek komunikacyjnych}: ścieżki w systemie powinny zapewniać optymalizacje bazującą na: awariach transmisji, kosztu i opóźnieniach, w momencie, gdy istnieją inne ścieżki do punktu docelowego. \cite{m2m-web}
\end{itemize}

\subsection{Technologie komunikacji M2M}
Poprawnym stwierdzeniem będzie, że obecnie znajdujmy się w epoce połączonych ze sobą obiektów. IoT (Internet of Things) zdobywa aktualnie coraz więcej uwagi nie mal w każdej domenie, a szczególnie w takich jak biznes, elektronika konsumencka, przemysł czy transport. Niemal każdy obiekt elektryczny w dzisiejszym świecie jest ze sobą połączony w ten czy inny sposób. Siedząc w biurze, za pomocą dostarczanych aplikacji, możemy kontrolować drzwi, bramę garażową, czajnik elektryczny czy rolety okienne w naszym domu. Z kolei w mieście kontrolujemy kamery i oświetlenie, a wszystko to z odległych lokacji. IoT odgrywa w tym ważną rolę, ponieważ to ono umożliwia łączenie przeróżnych obiektów, za pomocą sieci połączeń i wymianę danych między nimi.\cite{LoRa-article}


\newpage
\subsubsection{Ogólna klasyfikacja technolgi M2M}
Poniżej przedstawiono ogólne porównanie technologi komunikacyjnych M2M.


\begin{table}[!htbp]
\begin{center}  
  \resizebox{\textwidth}{!}{%
  \begin{tabular}{|l|l|l|l|}
  \hline
  \textbf{}            & \begin{tabular}[c]{@{}l@{}}\textbf{Local Area Network}\\ Komunikacja krótko \\ dystansowa\end{tabular}            & \begin{tabular}[c]{@{}l@{}}\textbf{Low Power Wide Area}\\ Intenet Of Things\end{tabular}            & \begin{tabular}[c]{@{}l@{}}\textbf{Celluar Network}\\ Tradycyjne M2M\end{tabular}                               \\ \hline
  \textbf{Użycie}      & 40\%                                                                                                              & 45\%                                                                                                & 15\%                                                                                                            \\ \hline
  \textbf{Zalety}      & \begin{tabular}[c]{@{}l@{}}- Dobrze ugruntowana norma\\ - W budynkach\end{tabular}                                & \begin{tabular}[c]{@{}l@{}}- Niskie zużycie energi\\ - Niskie koszty\\ - Pozycjonowanie\end{tabular} & \begin{tabular}[c]{@{}l@{}}- Istniejące pokrycie znacznego \\ obszaru\\ - Duża prędkość transmisji\end{tabular} \\ \hline
  \textbf{Wady}        & \begin{tabular}[c]{@{}l@{}}- Wysokie zużycie energi \\ elektrycznej\\ - Duży koszt sieci i zależności\end{tabular} & \begin{tabular}[c]{@{}l@{}}- Niska prędkość transmisji\\ - Wschodzący standard\end{tabular}         & \begin{tabular}[c]{@{}l@{}}- Wysoki koszt posiadania\\ - Mała autonomia\end{tabular}                            \\ \hline
  \textbf{Technologia} & Bluetooth, WiFi                                                                                                   & LoRa                                                                                                & GSM, 3G, 4G, 5G                                                                                                 \\ \hline
  \end{tabular}%
  }
  \caption{Porównanie rodzajów technologi M2M.\cite{LoRa-article}}
\end{center}
\source{Opracowanie własne.}
\end{table}

\subsubsection{LoRa}
Komunikacja w aplikacjach IoT jest dzisiaj wykonywana w przeróżnych technologiach, a każda z nich ma swoje zalety, funkcje, a przez to też przeznaczenie. Żadna z tych technologi nie może pokryć całego zapotrzebowania świata IoT, ponieważ wszystkie one posiadają cechy, które czynią je odpowiednie dla postawionego konkretnego zadania.

LoRa (Long Range) to nowa technologia połączeń bezprzewodowych w świecie IoT. Ostatnio znacznie ewoluowała i zyskała szczególną popularność w urządzeniach z ograniczoną pojemnością elektryczną, umożliwiając systemom wbudowanym przesyłanie małej ilości danych na dużych dystansach w krótkich interwałach czasowych.

WiFi to najpopularniejsza technologia komunikacji bezprzewodowej, która jest już rozwijana przez wiele lat. W kontekście IoT wykorzystywana jest przede wszystkim do komunikacji na dużych
odległościach. Na krótkie dystanse lepiej pasują do tego takie protokoły jak Bluetooth czy ZigBee. We wszystkich z nich największą wadą jest duże zużycie energii elektrycznej. Technologia Lora zapewnia bezpieczne, mobilne dwukierunkowe połączenie o niskim koszcie elektrycznym. Wykorzystywane jest ono w IoT, szczególnie w domenie smart city, czy nawet ogólnej komunikacji M2M. LoRa zalicza się do LPWA(Low Power Wide Area), czyli rodzaju bezprzewodowej rozległej sieci telekomunikacyjnej, stworzonej w celu umożliwienia komunikacji na duże odległości przy niskiej przepływności i niskim poborze energii. \cite{LPWA-wiki} W tego typu komunikacji wyróżnia się LoRa ze względu na jej:
\begin{itemize}
  \item długodystansowość;
  \item dwukierunkowość;
  \item wysoką pojemność węzłów w sieci;
  \item długość życia na baterii;
  \item odporność interfejsów;
  \item bezpieczeństwo i efektywność sieci. \cite{LoRa-article}
\end{itemize}


\myparagraph{Cechy}
Technologie tą wyróżniają następujące cechy:
\begin{itemize}
  \item Pojedyncza bramka może pokryć obszar aż $100km^2$;
  \item Oferuje ona podwójne szyfrowanie AES;
  \item Bazuje na technologi CSS (widmo rozproszone Chrip), które umożliwia śledzenie obiektów i jest odporne na zanikanie sygnałów;
  \item Topologia gwiazdy eliminuje zanikanie danych przez urządzenia pośrednie, co przyczynia się do zmniejszenia poboru mocy. \cite{LoRa-article}
\end{itemize}


\myparagraph{Ograniczenie przepustowości}
W sieci LoRa wszystkie klasy ramek wymagają potwierdzenia. Wiąże się z tym, że po każdym potwierdzeniu ramki przez urządzenie końcowe w dowolnym oknie czasowym następuje okres wyłączenia, w celu zachowanie zgodności z przepisami dotyczącymi cyklu pracy. W związku z tym, aby uniknąć wyczerpania limitu pojemności przez sieć i urządzenia końcowe, muszą one ograniczyć liczbę potwierdzeń. Również w podsieciach LoRa po przesłaniu danych następuje okres wyłączenia, w którym na danym kanale nie są wysyłane żadne dane. Te dwa okresy, tzn. okres wysyłania danych i wstrzymania transmisji stanowi cykl pracy. Cały ten mechanizm przyczynia się do ograniczenia przepustowości sieci.\cite{LoRa-article}

\subsubsection{Narowband IoT}
Wraz z rozwojem świata IoT zyskała również technologia Narowband IoT (NB-IoT). Wykorzystywana jest ona przede wszystkim przy komunikacji komórkowej dla zdalnych pomiarów w całej Europie. Jest to technologia dostępu radiowego. Używa ona ponownie kompnentów stworzonych przez jej poprzednika LTE, aby umożliwić jej działa na licencjonowanej częstotliwości. Może ona również działać w trybie autonomicznym. Tak jak sama nazwa wskazuje, cały system działa w wąskim spektrum częstotliwości, bo tylko w 200kHz, co wprowadza elastyczność zastosowań dzięki minimalnym wymaganiom częstotliwości, w porównaniu do jej poprzednika LTE. Cała szerokość 200kHz została podzielona na kanały po 3.75 kHz lub 15 kHz, co umożliwia połączenie w bardzo wysoką prędkość nadawania, a także daleki zasięg połącznia. \cite{nbiot-article}  

\subsubsection{NB-IoT vs Lora}
\begin{table}[H]
\begin{center}  \caption{Porównanie technologi LoRa i NB-IoT \cite{NB-IoT_vs_Lora}}
  
    \begin{tabular}{|l|c|c|}
      \hline
      \textbf{Parametr}                                                                     & \textbf{LoRa}               & \textbf{NB-IoT}       \\ \hline
      \textbf{Pasmo}                                                                        & 125 kHz                     & 180 kHz               \\ \hline
      \textbf{Pokrycie}                                                                     & 165 dB                      & 164 dB                \\ \hline
      \textbf{Żywotność baterii}                                                            & 15+ lat                     & 10+ lat               \\ \hline
      \textbf{\begin{tabular}[c]{@{}l@{}}Maksymalne natężenie \\ elektryczne\end{tabular}}  & 32 mA                       & 120 mA                \\ \hline
      \textbf{\begin{tabular}[c]{@{}l@{}}Spoczynkowe natężenie \\ elektryczne\end{tabular}} & 1 µA                        & 5 µA                  \\ \hline
      \textbf{Przepustowość}                                                                & 50 Kbps                     & 60 Kbps               \\ \hline
      \textbf{Opóźnienie}                                                                   & Zależne od klasy urządzenia & 10 s                  \\ \hline
      \textbf{Bezpieczeństwo}                                                               & AES 128 bit                 & 3GPP (128 to 256 bit) \\ \hline
      \textbf{Geolokalizacja}                                                               & Tak (TDOA)                  & Tak (In 3GPP Rel 14)  \\ \hline
      \textbf{Jakość/cena}                                                                  & Wysoka                      & Średnia                \\ \hline
      \end{tabular}%
  
\end{center}
\source{Badania własne.}
\end{table}

  
Zarówno LoRa, jak i NB-IoT należą do wspomnianej wcześniej technologi LPWAN. Podstawowa różnice pomiędzy tymi dwoma technologiami można dostrzec w zużyciu baterii, prędkości transmisji i opóźnień.

\subsection{Komunikacja bezprzewodowa w dronach konsumenckich}
Przeglądając katalog największego producenta dronów konsumenckich DJI, można wyróżnić tylko 3 technologie komunikacji bezprzewodowej: wzomocnione WiFi (ang. enhanced WiFi), Lightbridge, OcuSync.

\subsubsection{WiFi}
WiFi nie zostało wprowadzone ściśle do komunikacji bezprzewodowej statków powie-\\trznych, ale odnajduje się w tym całkiem dobrze. Jest ona wykorzystywana głównie w bardziej budżetowych wersjach dronów, ze względu na możliwość skorzystanie przez producenta z posiadanej przez użytkownika infrastruktury (smartfonów), czy niskiej ceny komponentów.

Przykładowo dron \textit{DJI Tello}, który jest najtańszą opcją dostępną od producenta DJI, przeznaczoną głównie do nauki latania i programowania, również przez najmłodszych pasjonatów. Nie posiada on w zestawie dedykowanego kontrolera, poniewąż odbywa się ono za pomocą aplikacji na smartfona, która łączy się z dronem za pomocą WiFi tak jak do punktu dostępowego z internetem. Zasięg takiego połączenia według producenta to 100 m.\cite{dji-store}


\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=10cm]{./Obrazy/dji-tello.jpg}
  \caption{DJI Tello}
  \end{center}
  \source{\myurl{https://store.dji.com}}
\end{figure}

W swojej ofercie DJI ma również dostępnego drona \textit{DJI Mini SE}, który również korzysta z technologii WiFi, ale w swoim wyposażaniu posiada dedykowany do niego kontroler. Taka konfiguracja pozwala na uzyskanie zasięgu do 2 km. \cite{dji-mavic-mini-se-spec}

WiFi jest także bardzo podatne na wszelkie zakłócenia, wynikające z ukształtowania terenu czy zaszumienia sieci pochodzącego z istniejących sieci domowych. Wyprodukowanie drona w tej technolgi jest najtańszą dostępną opcją, która umożliwia transmisje obrazu, jednak należy pamiętać, aby nie stawiać jej przy tym za dużych wymagań. Stanowi ono dobry punkt startowy w komunikacji bezprzewodowej bezzałogowych statków powietrznych.

\subsubsection{Lightbridge}

Lightbridge to technologia od DJI, która doczekała się jej dwóch wydań. Pierwszych wzmianek o niej można doszukiwać się w 2014 r., a drugiego wydania już w 2015 roku. Jest ona zbliżona do technologii WiFi, przede wszystkim transmisja ta odbywa się na tej samej częstotliwości 2,4GHz.


Była ona kierowana głównie do dronów z wyższego pułapu cenowego, dlatego że jej produkcja była bardzo kosztowna, a koszt wynikał z tego, że producent opracował to rozwiązanie na swoim autorskim układzie scalonym i oprogramowaniu. Umożliwiło to osiągnąć duże lepsze wyniki niż transmisja po WiFi. Zasięg lotu według producenta to odległość do 5 km.


Obecnie Lightbridge nie jest już rozwijany, a producent skupił się na jego następniku, technologi OcuSync. \cite{lightbridge-dji}\cite{lightbridge2-dji}

\subsubsection{OcuSync} 
OcuSync został po raz pierwszy zademonstrowany przez producenta wraz z wydaniem drona \emph{Mavic Mini Pro}. Pierwsze wydanie tej technologi pozwalało na transmisje do 7 km na częstotliwości 2,4 GHz. Obraz mógł być przesyłany w rozdzielczości 720p i 1080p. Jakość fullHD była dostępna tylko na krótszych odległościach. Na większych dystansach gdy dostępna prędkość transmisji spadała, dron przechodził automatycznie na transmisje w 720 p. Opóźnienie było rzędu 160-170ms. A największą cechą wyróżniającą tę technologię była możliwość podłączenia jednocześnie dwóch kontrolerów i do 4 urządzeń odbiorczych.

Kolejnym krokiem było wydane wersji oznaczonej jako OcuSync 1.5, w której dodano transmisję również na częstotliwości 5 Ghz. Zmniejszono także opóźnienia w transmisji. Dodatkowo technologia umożliwiał automatyczną zmianę kanałów komunikacyjnych w trakcie lotu na te najmniej obciążone. W pierwszej wersji kanał
transmisji można było wybrać tylko przed startem bezzałogowego statku powietrznego.\cite{ocusync-yt}


\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=8cm]{./Obrazy/dji-google.png}
  \caption{Pierwsza wersja gogli do FPV od DJI}
  \end{center}
  \source{\myurl{https://u.cyfrowe.pl/600x0/2/7/2_732250420.png}}
\end{figure}

  
  
\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=8cm]{./Obrazy/dji-air-unit.png}
  \caption{Dji OcuSync Air Unit}
  \end{center}
  \source{\myurl{https://store.dji.com}}
\end{figure}


Wraz z wydaniem nowej wersji zaprezentowano \textit{gogle DJI} przeznaczone do transmisji obrazu w trybie FPV (ang. first person view, widok pierwszo-osobowy) i również \textit{OcuSync Aircraft System}, czyli zintegrowanego systemu umożliwiającego sterowanie i transmisji obrazu z wykorzystaniem tej technologi w dronach i pojazdach DIY.

Producent w trakcie swojej historii doprowadził do pewnych nieścisłości. Pomimo że dron \textit{Phantom 4 pro v 2.0} korzystał teoretycznie z najnowszej wersji OcuSync, nie posiadał on możliwości zmiany kanałów transmisji w trakcie lotu, a opóźnienie zależało też od tego, czy korzystano z kontrolera dołączonego do zestawu, czy jego droższej, lepiej wyposażonej wersji: \textit{DJI RC Plus}.
  

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=8cm]{./Obrazy/dji-phantom-v2.jpg}
  \caption{DJI Phantom v2.0}
  \end{center}
  \source{\myurl{https://store.dji.com}}
\end{figure}

  
  
\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=8cm]{./Obrazy/dji-rc-plus.png}
  \caption{DJI RC plus}
  \end{center}
  \source{\myurl{https://store.dji.com}}
\end{figure}

  
  

Wersja 2.0 wprowadziła dalsze ulepszenia, m.in. kontrolowanie dronów na jeszcze większe dystanse i z jeszcze mniejszymi opóźnieniami, a także kompatybilność wsteczną po aktualizacji oprogramowania.

\newpage
\subsubsection{FHSS i  OFDM}

Zarówno Lightbridge, jak i OcuSync używają szyfrowanej modulacji OFDM (ang. Orthogonal Frequency-Division Multiplexing, zwielokrotnianie z ortogonalnym podziałem częstotliwości)) dla transmisji obrazu i z formy FHSS (ang. Frequency-Hopping Spread Spectrum) dla transmisji sygnałów sterowania. Kanał dla transmisji obrazu nie zmienia się w trakcie całego lotu, pod warunkiem, że nie następują zakłócenia, albo użytkownik nie ustawi ręcznie innej częstotliwości. Z kolei metoda FHSS "skacze" po częstotliwościach w całym dostępnym widmie, w tym nawet w pasmie przeznaczonym do transmisji obrazu.\cite{FHSS-wiki} \cite{OFDM-wiki}

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=14cm]{./Obrazy/ocusync_spectrum_1.png}
\caption{Widmo OFDM i FHSS}
\end{center}
\source{\myurl{https://www.youtube.com/watch?v=gfqcSv9sR0A}}
\end{figure}

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=14cm]{./Obrazy/ocusync_spectrum_2.png}
\caption{Widmo OcuSync z zaznaczoną modulacja FHSS i OFDM}
\end{center}
\source{\myurl{https://www.youtube.com/watch?v=gfqcSv9sR0A}}
\end{figure}


\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=14cm]{./Obrazy/ocusync_vs_lightbridge.png}
\caption{Porównanie widma OcuSync i Lightbridge}
\end{center}
\source{\myurl{https://www.youtube.com/watch?v=gfqcSv9sR0A}}v
\end{figure}

\newpage

\subsubsection{Przewaga OcuSync nad Lightbridge}
OcuSync stało się główną technologią rozwijaną przez DJI. Producent wykorzystuje układy scalone przeznaczone do komunikacji WiFi. Wytwarza na nie swoje oprogramowania, która można bez problemu aktualizować. Lightbridge nie miał takiej możliwości, a w dodatku komunikacji opierała się wyłącznie na paśmie 2,4GHz. Nowe procesory w układach WiFi dzięki coraz większej częstotliwości pracy zapewniły osiąganie tych samych efektów, co DJI uzyskiwał za pomocą autorskich układów scalonych, bez dodatkowego kosztu wynikającego z produkcji.

\subsection{Kontrolowanie BSP za pomocą API dostarczaonego od producenta}
Przeszukując internet w poszukiwaniu bezzałogowych statków powietrznych umożliwiających ich sterowanie za pomocą API od producenta, można napotkać głównie rozwiązania od DJI. Wszystkie pozostałe rozwiązania nie działają na gotowych dronach, a na oprogramowaniu przeznaczonym do wgrania na wybranych jednostkach do sterowania modelami RC.

Najpopularniejszym tego rozwiązaniem jest ArduPilot, czyli pakiet oprogramowania nawigacyjnego działającego w pojeździe wraz z oprogramowaniem sterującym stacją naziemną.

\subsubsection{DJI SDK}
DJI dostarcza do swoich produktów następujące interfejsy API:
\begin{enumerate}
  \item \textbf{App Dev.} - interfejsy API przeznaczone do sterowania dronem z poziomu stacji bazowej, kontroler stanowi interfejs pośredniczący między aplikacją wykorzystującą SDK a dronem powietrznym:\begin{enumerate}
    \item \textbf{Mobile SDK} - SDK przeznaczona na platformę iOS i Android. Aplikacja na smartfon za pomocą kabla USB podłączonego do kontrolera statku powietrznego realizuje zaprogramowaną logikę działania.
    \item \textbf{UX SDK} - to Mobile SDK rozszerzony o elementy interfejsu użytkownika, co przyspiesza znacznie proces tworzenia oprogramowania.
    \item \textbf{Windows SDK} - SDK umożliwiające wydawanie aplikacji na systemach operacyjnych Windows. 
  \end{enumerate}
  \item \textbf{Payload Dev.} - interfejsy API przeznaczone do nadawania logiki działania drona na poziomie samego drona, dzięki temu po utracie zasięgu może ona dalej funkcjonować. Opcja dostępna dla najdroższych wersji dronów DJI, które można dostosowywać do swoich wymagań za pomocą odpowiednich rozszerzeń, np. kamery termowizyjnej\begin{enumerate}
    \item \textbf{Payload SDK} - zestaw narzędzi programistycznych umożliwiających tworzenie oprogramowania do rozszerzeń, które mogą być montowane na dronach DJI. 
    \item \textbf{Onboard SDK} - otwarto-źródłowe API umożliwiające bezpośrednią komunikację z wybranymi dronami i kontrolerami za pomocą interfejsu szeregowego.
  \end{enumerate}
\end{enumerate}

\newpage
\section{Projekt mobilnego systemu zarządzania i sterowania BSP}
\subsection{Wymagania funkcjonalne}
Poniżej przedstawiono diagram przypadków użycia systemu (Rys. 18.). Można na nim wyróznić następujących aktorów:
\begin{itemize}
\item \textbf{Operator} - jedyna fizyczna osoba, która opowiada za wprowadzenie danych brokera MQTT do urządzenia mobilnego;
\item \textbf{Broker MQTT} - za pomocą którego przysyłane są komendy do BSP;
\item \textbf{BSP z kontrolerem} - odbiera polecenia i realizuje ich treść.
\end{itemize}
W tabelach nr 3-24 opisano poszczególne przypadki użycia.
\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator: &
    UC1 \\ \hline
  Nazwa przypadku użycia: &
    Konfiguracja ustawień brokera MQTT \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Operator wprowadza dane poterzbne do\\ komunikacji z brokerem MQTT (login,\\ hasło, adres)\end{tabular} \\ \hline
  Aktor inicjalizujący: &
    Operator \\ \hline
  Warunki wstępne: &
    \begin{tabular}[c]{@{}l@{}}Urządzenie mobline komunikuje sie z \\ kontrolerem BSP\end{tabular} \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Aplikacja mobilna wyświetla formularz\\ 2. Operator wprowadza dane logowania\\ 3. Aplikacja sprawdza poprawność danych\\ i połącznie z serwerem.\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Aplikacja rozpocznie kontrolowanie drona\\ i oczekiwania na komendy do wykonania\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC1}
\end{center}
\source{Opracowanie własne.}
\end{table}

\newpage

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=14cm]{./Obrazy/UseCaseDiagram0.png}
\caption{Diagram przypadków użycia}
\source{Opracowanie własne.}
\end{center}
\end{figure}
  

\begin{table}[H]
\begin{center}
    \begin{tabular}{|l|l|}
    \hline
    Identyfikator:           & UC2                  \\ \hline
    Nazwa przypadku użycia:  & Przesłanie polecenia \\ \hline
    Opis przypadku użycia: &
      \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie\end{tabular} \\ \hline
    Aktor inicjalizujący:    & Broker MQTT          \\ \hline
    Warunki wstępne:         & BRAK                 \\ \hline
    Scenariusz główny: &
      \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła \\ komende przeznaczoną dla BSP \\ 2. BSP otrzymuje podaną komende
      \end{tabular} \\ \hline
   \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} &
      BSP realizuje otrzymaną komendę \\ \hline
    \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular} &
      BRAK \\ \hline
    \end{tabular}
    \caption{Specyfikacja przypadku użycia UC2}
\end{center}
  \source{Opracowanie własne.}
\end{table}
    

  
\begin{table}[H]
\begin{center}    \begin{tabular}{|l|l|}
    \hline
    Identyfikator:           & UC4                            \\ \hline
    Nazwa przypadku użycia:  & Włącznia silników              \\ \hline
    Opis przypadku użycia: &
      \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie włączenia silników\end{tabular} \\ \hline
    Aktor inicjalizujący:    & Broker MQTT                    \\ \hline
    Warunki wstępne:         & BSP nie ma włączonych silników \\ \hline
    Scenariusz główny: &
      \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła \\ komende przeznaczoną dla BSP dotyczącą \\ włączenia silników \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} &
      BSP włącza silniki \\ \hline
    \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular} &
      BRAK \\ \hline
    \end{tabular}
    \caption{Specyfikacja przypadku użycia UC4}
\end{center}
  \source{Opracowanie własne.}
\end{table}
  


\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:           & UC5                                    \\ \hline
  Nazwa przypadku użycia:  & Wyłącznia silników                     \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie wyłączenia silników\end{tabular} \\ \hline
  Aktor inicjalizujący:    & Broker MQTT                            \\ \hline
  Warunki wstępne:         & BSP nie ma włączone silniki i nie lata \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła \\ komende przeznaczoną dla BSP dotyczącą \\ wyłączenia silników \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP wyłącza silniki \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC5}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:           & UC6           \\ \hline
  Nazwa przypadku użycia:  & Wystartowania \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie wystartowania\end{tabular} \\ \hline
  Aktor inicjalizujący:    & Broker MQTT   \\ \hline
  Warunki wstępne:         & BSP nie lata  \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła \\ komende przeznaczoną dla BSP dotyczącą \\ wystartowania \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP startuje \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC6}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:           & UC3         \\ \hline
  Nazwa przypadku użycia:  & Wylądowania \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie wylądowania\end{tabular} \\ \hline
  Aktor inicjalizujący:    & Broker MQTT \\ \hline
  Warunki wstępne:         & BSP lata    \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła \\ komende przeznaczoną dla BSP dotyczącą \\ wylądowania \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP ląduje \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular} &
    Rozszerzone: UC7 \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC3}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}    \begin{tabular}{|l|l|}
    \hline
    Identyfikator:           & UC7                              \\ \hline
    Nazwa przypadku użycia:  & Potwierdzenie lądowania          \\ \hline
    Opis przypadku użycia:   & BSP potwierdza lądowania         \\ \hline
    Aktor inicjalizujący:    & BSP z kontrolerem                \\ \hline
    Warunki wstępne:         & BSP otrzymał komende wylądowania \\ \hline
    Scenariusz główny:       & 1. BSP potwierdza lądowanie      \\ \hline
    \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i \\ wykonaniu scenariusza głównego:\end{tabular} & BSP ląduje       \\ \hline
    \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki \\ użycia:\end{tabular}                  & Rozszerzone: UC7 \\ \hline
    \end{tabular}
    \caption{Specyfikacja przypadku użycia UC7}
\end{center}
  \source{Opracowanie własne.}
\end{table}
  


\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:                                                                    & UC8                              \\ \hline
  Nazwa przypadku użycia:                                                           & Ustawienia lokalizacji startowej \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende, która ustawia \\ lokalizacje GoToHome\end{tabular} \\ \hline
  Aktor inicjalizujący:                                                             & Broker MQTT                      \\ \hline
  Warunki wstępne:                                                                  & BRAK                             \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende przeznaczoną dla BSP dotyczącą\\ ustawienie lokalizacji GoToHome \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Lokalizacja GoToHome na BSP ma nowe \\ współrzędne\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} & BRAK                             \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC8}
\end{center}
\source{Opracowanie własne.}
\end{table}
  



\begin{table}[H]
\begin{center}    \begin{tabular}{|l|l|}
    \hline
    Identyfikator:                                                                    & UC9                                       \\ \hline
    Nazwa przypadku użycia:                                                           & Rozpoczęcia lotu do lokalizacji startowej \\ \hline
    Opis przypadku użycia: &
      \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie rozpoczęcia lotu\\ do lokalizacji GoToHome\end{tabular} \\ \hline
    Aktor inicjalizujący:                                                             & Broker MQTT                               \\ \hline
    Warunki wstępne:                                                                  & BRAK                                      \\ \hline
    Scenariusz główny: &
      \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ polecenie rozpoczęcia lotu\\ do lokalizacji GoToHome \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
      \begin{tabular}[c]{@{}l@{}}BSP rozpoczyna lot do lokalizacji \\ GoToHome\end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} & BRAK                                      \\ \hline
    \end{tabular}
    \caption{Specyfikacja przypadku użycia UC9}
\end{center}
  \source{Opracowanie własne.}
\end{table}
  


\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:                                                                    & UC10                                      \\ \hline
  Nazwa przypadku użycia:                                                           & Zakończenia lotu do lokalizacji startowej \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie zakończenia lotu\\ do lokalizacji GoToHome\end{tabular} \\ \hline
  Aktor inicjalizujący:                                                             & Broker MQTT                               \\ \hline
  Warunki wstępne:                                                                  & BRAK                                      \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ polecenie zakończenia lotu\\ do lokalizacji GoToHome \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}BSP kończy lot do lokalizacji \\ GoToHome\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} & BRAK                                      \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC10}
\end{center}
\source{Opracowanie własne.}
\end{table}
  


\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:          & UC11              \\ \hline
  Nazwa przypadku użycia: & Zrobienia zdjecia \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła polecenie wykonania zdjęcia\end{tabular} \\ \hline
  Aktor inicjalizujący:   & Broker MQTT       \\ \hline
  Warunki wstępne:        & BRAK              \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ polecenie wykonania zdjęcia \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP wykonuje zdjęcia \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    Zawarte: UC12 \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC11}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator: &
    UC12 \\ \hline
  Nazwa przypadku użycia: &
    Przesłanie obrazu do brokera MQTT \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}BSP zwraca zdjęcie na indywidualny Topic \\ MQTT\end{tabular} \\ \hline
  Aktor inicjalizujący: &
    Broker MQTT \\ \hline
  Warunki wstępne: &
    BRAK \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. BSP na podany Topic przesyła wykonane \\ zdjęcie \\ 2. Broker MQTT otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Zdjęcie w postaci wiadmości MQTT znajduje\\ się na Topicu MQTT\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC12}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:          & UC13             \\ \hline
  Nazwa przypadku użycia: & Przesłania misji \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende z danymi misji\end{tabular} \\ \hline
  Aktor inicjalizujący:   & Broker MQTT      \\ \hline
  Warunki wstępne:        & BRAK             \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende z danymi misji \\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    Urządzenie mobiline otrzymuje dane misji \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC13}
\end{center}
\source{Opracowanie własne.}
\end{table}




\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:                                                                    & UC14                                      \\ \hline
  Nazwa przypadku użycia:                                                           & Załadowania misji                         \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende załadowania misji\end{tabular} \\ \hline
  Aktor inicjalizujący:                                                             & Broker MQTT                               \\ \hline
  Warunki wstępne:                                                                  & Urządzenie mobilne przechowuje dane misji \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende załadowania misji\\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Urządzenie mobilne przesyła na BSP dane\\ misji\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} & BRAK                                      \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC14}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:          & UC15                          \\ \hline
  Nazwa przypadku użycia: & Rozpoczęcia wykonywania misji \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende rozpoczęcia wykonywania\\ misji\end{tabular} \\ \hline
  Aktor inicjalizujący:   & Broker MQTT                   \\ \hline
  Warunki wstępne:        & BSP przechowuje dane misji    \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende rozpoczęcia wykonywania misji\\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP wykonuje misje \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC15}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:          & UC16                                 \\ \hline
  Nazwa przypadku użycia: & Wstrzymania wykonywania misji        \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende wstrzymania wykonywania\\ misji\end{tabular} \\ \hline
  Aktor inicjalizujący:   & Broker MQTT                          \\ \hline
  Warunki wstępne:        & BSP jest w trakcie wykonywania misji \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende wstrzymania wykonywania misji\\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP wstrzymało wykonywanie misji \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC16}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:          & UC17                            \\ \hline
  Nazwa przypadku użycia: & Wznowienie wykonywania misji    \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende wznowienia wykonywania\\ misji\end{tabular} \\ \hline
  Aktor inicjalizujący:   & Broker MQTT                     \\ \hline
  Warunki wstępne:        & BSP wstrzymał wykonywanie misji \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende wznowienia wykonywania misji\\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP wznawia wykonywanie misji \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC17}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}  \begin{tabular}{|l|l|}
  \hline
  Identyfikator:          & UC18                                \\ \hline
  Nazwa przypadku użycia: & Zakończenia wykonywania misji       \\ \hline
  Opis przypadku użycia: &
    \begin{tabular}[c]{@{}l@{}}Broker MQTT na indywidualny Topic BSP\\ przesyła komende zakończenia wykonywania\\ misji\\ 2. BSP otrzymuje podaną komende\end{tabular} \\ \hline
  Aktor inicjalizujący:   & Broker MQTT                         \\ \hline
  Warunki wstępne:        & BSP był w trakcie wykonywania misji \\ \hline
  Scenariusz główny: &
    \begin{tabular}[c]{@{}l@{}}1. Broker MQTT na podany Topic przesyła\\ komende wstrzymania wykonywania misji\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
    BSP zakończył wykonywanie misji \\ \hline
  \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
    BRAK \\ \hline
  \end{tabular}
  \caption{Specyfikacja przypadku użycia UC18}
\end{center}
\source{Opracowanie własne.}
\end{table}



\begin{table}[H]
\begin{center}    \begin{tabular}{|l|l|}
    \hline
    Identyfikator: &
      UC19 \\ \hline
    Nazwa przypadku użycia: &
      Akwizycja obrazu \\ \hline
    Opis przypadku użycia: &
      \begin{tabular}[c]{@{}l@{}}BSP zapisuje aktualny obraz\\ z kamery\end{tabular} \\ \hline
    Aktor inicjalizujący: &
      BSP z kontrolerem \\ \hline
    Warunki wstępne: &
      BRAK \\ \hline
    Scenariusz główny: &
      \begin{tabular}[c]{@{}l@{}}1. BSP zapisuje aktualny obraz\\ z kamery\end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
      \begin{tabular}[c]{@{}l@{}}BSP w swojej pamięci posiada obraz z\\ kamery wykonany w danej chwili\end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
      BRAK \\ \hline
    \end{tabular}
    \caption{Specyfikacja przypadku użycia UC19}
\end{center}
  \source{Opracowanie własne.}
\end{table}
  

  
  \begin{table}[H]
  \begin{center}    \begin{tabular}{|l|l|}
      \hline
      Identyfikator:                                                                    & UC20                                \\ \hline
      Nazwa przypadku użycia:                                                           & Potwierdzenie odebrania polecenia   \\ \hline
      Opis przypadku użycia:                                                            & BSP potwierdza otrzymanie polecenia \\ \hline
      Aktor inicjalizujący:                                                             & BSP z kontrolerem                   \\ \hline
      Warunki wstępne:                                                                  & BRAK                                \\ \hline
      Scenariusz główny: &
        \begin{tabular}[c]{@{}l@{}}1. BSP potwierdza otrzymanie polecenia poprzez\\ opublikowania na indywidulanym Topicu\\ odpowiedniego logu.\end{tabular} \\ \hline
      \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
        \begin{tabular}[c]{@{}l@{}}Na indywidualnym Topicu BSP znajduje sie log\\ potwierdzający otrzymanie zadania.\end{tabular} \\ \hline
      \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} & BRAK                                \\ \hline
      \end{tabular}
      \caption{Specyfikacja przypadku użycia UC20}
\end{center}
\source{Opracowanie własne.}
\end{table}
    
  \begin{table}[H]
  \begin{center}    \begin{tabular}{|l|l|}
      \hline
      Identyfikator: &
        UC21 \\ \hline
      Nazwa przypadku użycia: &
        Wysłanie statusu \\ \hline
      Opis przypadku użycia: &
        BSP wysyła swój status \\ \hline
      Aktor inicjalizujący: &
        BSP z kontrolerem \\ \hline
      Warunki wstępne: &
        BRAK \\ \hline
      Scenariusz główny: &
        \begin{tabular}[c]{@{}l@{}}1. BSP wysyła swój status\\ na indywidulnym Topic\end{tabular} \\ \hline
      \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
        \begin{tabular}[c]{@{}l@{}}Na indywidualnym Topicu BSP znajduje sie \\ status BSP\end{tabular} \\ \hline
      \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} &
        Zawarte: UC22 \\ \hline
      \end{tabular}
      \caption{Specyfikacja przypadku użycia UC21}
\end{center}
\source{Opracowanie własne.}
\end{table}
    

  
    \begin{table}[H]
    \begin{center}    \begin{tabular}{|l|l|}
        \hline
        Identyfikator:                                                                    & UC22                                   \\ \hline
        Nazwa przypadku użycia:                                                           & Przesłanie telemetri                   \\ \hline
        Opis przypadku użycia:                                                            & BSP przesyła dane dotyczące telemetrii \\ \hline
        Aktor inicjalizujący:                                                             & BSP z kontrolerem                      \\ \hline
        Warunki wstępne:                                                                  & BRAK                                   \\ \hline
        Scenariusz główny: &
          \begin{tabular}[c]{@{}l@{}}1. BSP przesyła dane dotyczące telemetrii\\ na indywidualny Topic\end{tabular} \\ \hline
        \begin{tabular}[c]{@{}l@{}}Po spełnieniu warunków i\\ wykonaniu scenariusza głównego:\end{tabular} &
          \begin{tabular}[c]{@{}l@{}}Na indywidualnym Topicu BSP znajdują się\\ dane telemetryczne\end{tabular} \\ \hline
        \begin{tabular}[c]{@{}l@{}}Zawarte i rozszerzone przypadki\\ użycia:\end{tabular} & BRAK                                   \\ \hline
        \end{tabular}
\caption{Specyfikacja przypadku użycia UC22}
\end{center}
\source{Opracowanie własne.}
\end{table}
      

\newpage


\subsection{Wymagania pozafunkcjonalne}
\begin{table}[H]
\begin{center}  \caption{Wymagania pozafunkcjonalne}
  
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Lp.} & \textbf{Opis}                                                                                                                                                                \\ \hline
      1            & \begin{tabular}[c]{@{}l@{}}Aplikacja musi po zerwaniu połączenia z brokerem MQTT automatycznie \\ ją przywrócić wraz z subskrybowanymi Topic-a.\end{tabular}                 \\ \hline
      2            & \begin{tabular}[c]{@{}l@{}}Aplikacja powinna mieć możliwość ustawienia czasu po jakim operacje \\ na protokole MQTT zostaną uznane za zakończone niepowodzeniem.\end{tabular} \\ \hline
      3            & \begin{tabular}[c]{@{}l@{}}Aplikacja musi komunikować się na indywidualnych Topic-ach danego \\ statku powietrznego.\end{tabular}                                            \\ \hline
      4            & \begin{tabular}[c]{@{}l@{}}Aplikacja powinna, w ścieżkach określających Topic-i MQTT, zawierać \\ numer seryjny urządzenia.\end{tabular}                                       \\ \hline
      5            & \begin{tabular}[c]{@{}l@{}}Aplikacja powinna przy komunikacji z brokerem MQTT jako swój \\ identyfikator klienta używać numeru seryjnego urządzenia.\end{tabular}            \\ \hline
      6            & Komunikacja MQTT musi być zabezpieczona loginem i hasłem.                                                                                                                    \\ \hline
      7            & \begin{tabular}[c]{@{}l@{}}Aplikacja musi automatycznie potwierdzać lądowania urządzenia, jeżeli\\ jest to wymagane.\end{tabular}                                            \\ \hline
      8            & \begin{tabular}[c]{@{}l@{}}Aplikacja powinna mieć możliwość ustawiania interwału czasowego \\ w jakim zostaną przesłane dane dotyczące statusu statku.\end{tabular}          \\ \hline
      9            & \begin{tabular}[c]{@{}l@{}}Aplikacja powinna przesyłać obrazy minimum w rozdzielczości HD.\end{tabular}          \\ \hline
      10           & \begin{tabular}[c]{@{}l@{}}W przypadku braku połączenia sieciowego, system musi kontynuwać \\realizacje otrzymanych poleceń i automatycznie wznowić komunikacje \\ z punktem centralnym przy pierwszej możliwej okazji.\end{tabular}                                                         \\ \hline
      11           & \begin{tabular}[c]{@{}l@{}}Aplikacja powinna przesyłać informacje zwrotną dotyczącą wykonania \\ komendy na dedykowany Topic.\end{tabular}                                   \\ \hline
      \end{tabular}
  
\end{center}
\source{Badania własne.}
\end{table}

\subsection{Stos technologiczny}
Na wstępie warto zaznaczyć, że większość technologii w stosie technologicznym jest wyłącznie najrozsądniejszą odpowiedzią na wcześniej podjęte decyzje.

Pierwszą decyzją w tym ciągu przyczynowo-skutkowym było wybranie \textit{DJI Mobile SDK}, który pozwala na obsługe większości dronów dostępnych na rynku. Biblioteka ta dostarcza szereg możliwości i została ona dobrze udokumentowana. Taki wybór ogranicza nas do dwóch platform mobilnych Android i iOS. Ciężko dostrzec znaczącą przewagę technologiczną w którekolwiek z nich. Wybór jednak padł na platformę Android, ze względu na doświadczenie autora z nią i w praktyce tańsze urządzenia mobilne.

Ostatnio dużą popularnością w kontekście pisania aplikacji mobilnych zyskuje \textit{Flutter}. Głównie ze względu na swoją wieloplatformowość, dzięki której nie ma potrzeby utrzymywania dwóch kodów przeznaczonych na platformy Android i iOS, a wyłącznie jednej, która działa na obu. Jednak biblioteka dostarczona od DJI jest biblioteką w języku Java, wymusza to na nas pisanie natywnej aplikacji w Androidzie. Tak więc wykorzystanie wcześniej wspomnianego narzędzia, nie przyniesie dodatkowych korzyści.

Natywne aplikacje w Androidzie działają na wirtualnej maszynie Javy. Takie ograniczenie pozwala na wykorzystanie również języka programowania Kotlin. Jest on wykonywany w języku Java i zapewnia pełną z nią interoperacyjność. Korzyścią odniesioną z wykorzystania tego języka jest większa kontrola nad wartościami \textit{null}, którą wymusza Kotlin. Dostarcza on także szereg narzędzi skracających zapisy kodu, który realizowałby tę samą funkcjonalność w czystej Javie.

Kolejny wybór, jakiego należało dokonać to narzędzia do automatycznej budowy oprogramowania. W kontekście Javy wybór ogranicza się praktycznie do \textit{Maven} i \textit{Gradle}. Zarządzanie zależnościami i ich obsługa jest identyczna. Wybór padł na \textit{Gradle}, głównie ze względu na osobiste doświadczenie autora i brak sympatii do formatu \textit{xml}, który w \textit{Maven} jest obecny.

Ostatni etap to wybór technologii, za pomocą której będzie odbywała się komunikacja serwera z pojedynczymi BSP. Najpopularniejsze podejście polegające na stworzeniu RestAPI nie jest możliwe, ponieważ nie obsługuje ono przypadku, w którym połączenie zostanie przerwane, a w tego typu projekcie należy zakładać, że takie zakłócenia mogą występować. Tak więc wybór padł na protokół komunikacyjny MQTT, który dostarcza narzędzia odporne na zakłócenia w połączeniu sieciowym.

Podsumowując, stos technologiczny prezentuje się następująco:
\begin{itemize}
    \setlength\itemsep{1mm} %TODO
  \item DJI Mobile SDK - biblioteka umożliwiająca kontrolowanie drona DJI;
  \item Android - platforma mobilna, na której będzie uruchomiona aplikacja kontolująca;
  \item Kotlin i Java - języki, w których będzie pisana aplikacja;
  \item Gradle - narzędzie do budowania kodu i zarządzania zależnościami;
  \item MQTT - technologia komunikacji między aplikacją a punktem centralnym.
\end{itemize}

\newpage
\subsection{Diagram architekutry wysokopoziomowej}

Taka jak wspominono we wstępie, opracowanie całego systmu do zarządzanie rojem dronów wykracza poza możliwości tej pracy dyplomowej, ale warto zaprezentować wizje takiego systemu, aby nakreślić miejsce którego dotyczy ta prac. Poniżej przedstawiono obrazujący cały system diagram architektury wysokopoziomowej (Rys. 19.).  Produktem widocznym dla użytkownika końcowego będzie strona webowa umożliwiająca kontrole i zarządzanie całym rojem dronów, podgląd ich danych, a także przetworzanie ich przez algorytmy sztucznej inteligencji. Najważniejszym takim algorytmem będzie rozpoznawanie obiektów umieszczonych na obrazie odebranym z BSP. W przypadku, w którym system miałby być wykorzystany w obszarze militarnym, rozpoznawanie byłoby nastawione na ludzi i sprzęt wojskowy, tak aby operator roju, jak najszybciej uzyskiwał istotną na polu walki informacje.

Cała komunikacja odbywać się będzie za pomocą brokera MQTT, który tak jak każdy z elementów w tej architekturze w kolorze błękitnym może zostać zduplikowany. W ten sposób cała architektura jest odporna na zakłócenia komunikacyjne i uszkodzenia fizyczne sprzętu.

Celem tej pracy jest skonstruowanie oprogramowania umożliwiającego kontrolę BSP i przesyłanie z niego danych za pomocą brokera MQTT (obszar oznaczony na rysunku kolorem pomarańczowym).

\newpage

\begin{figure}[H]
\begin{center}
  \includegraphics[width=12cm]{./Obrazy/highlevel.png}
  \caption{Diagram architekutry wysokopoziomowej}
\end{center}
  \source{Opracowanie własne.}
\end{figure}

\newpage
\subsection{Diagram komponentów}
\begin{figure}[H]
\begin{center}
  \includegraphics[width=14cm]{./Obrazy/Component Diagram0.png}
  \caption{Diagram komponentów}
\end{center}
  \source{Opracowanie własne.}
\end{figure}

\newpage
Komunikacja dronów w ramach systemu odbywa się przy pomocy brokera MQTT. Oporgramowanie za jego pośrednictwem może pobierać dane ze statku i wydawać określone komendy. W ramach urządzenia mobilnego są wyróżnione trzy komponenty:
  \begin{itemize}
  \item \textbf{Mqtt Services} to serwisy, które realizują komunikacje z brokerem MQTT. Ich projekt i implementacja dązy do tego, aby API wystawione do komponentu \textit{FlightController} wymagało minimalnej obsługi.
  \item \textbf{DJI SDK} to dwie biblioteki dostarczane przez producenta: \textit{DJI SDK} i \textit{DJI UXSDK}. Pierwsza z nich udostępnia metody umożliwiające sterowanie dronem i odczytywanie jego parametrów, a druga dostarcza komponenty w Androidzie umożliwiające obsługę drona za pomocą elementów graficznych.
  \item \textbf{FlightController} korzysta z dwóch wcześniej wymienionych komponentów, w nim zawarta jest logika kontrolwania drona.
  \end{itemize}
Kontroler Ocusync, a dalej dron, są sterowane za pomocą wspomnanej biblioteki dostarczonej przez producenta.

\subsection{Diagramy klas}
Poniżej przedstawiono diagramy klasy przedstawiające projekt oprogramowania.

\subsubsection{Diagram klas ograniczony do dostępnych komend w ramach systemu}

Przy projektowaniu abstrakcji komend, które można wydawać systemowi BSP, można wyróżnić dwa podejścia. Pierwsze z nich, które jest zaprezentowane poniżej (Rys. 21.), polega na przedstawianiu każdej z nich w postaci osobnej klasy z przyrostkiem \textit{Command}. Dziedziczą one po klasie \textit{Command}, która posiada abstrakcyjną metodę \textit{exec}. Celem tej metody jest zrealizowanie polecenia tożsamego z daną komendą, za pomocą obiektów dostarczonych przez DTO \textit{AircraftControllers}.

Na diagramie przedstawiono również dwie istotne klasy \textit{CommandFactory} i \textit{CommandHandler}. Celem pierwszej z nich jest zwrócenie odpowiedniej instancji klasy dziedziczącej po \textit{Command}, na podstawie wartości tekstowej w formacie JSON. \textit{CommandHandler} odpowiada za odbieranie tych wartości za pomocą serwisu \textit{ReceiveService}, a następnie zmapowanie jej za pomocą \textit{CommandFactory} i wywołanie metody \textit{exec} z klasy \textit{Command}.

Wspomniane wcześniej drugie podejście, polegałoby na przedstawieniu tych komend w postaci wartości typu wyliczeniowego (enum). Jednak należy wtedy przyjrzeć się, jak wyglądałoby dodawanie kolejnych komend do systemu. Obecnie, aby dodać nową komendę do systemu należy utworzyć nową klasę, która dziedziczy po \textit{Command}, a następnie dodanie jej przypadku do \textit{CommandFactory}. Modyfikujemy kod w ten sposób tylko w jednym miejscu. Klasa \textit{CommandHandler}, która posiada dużą odpowiedzialność, pozostanie niezmieniona. W przypadku, gdyby zastosowano podejście z typem wyliczeniowym, dodanie kolejnej komendy do systemu, wiązałoby się z modyfikacją, oprócz wcześniej wspomnianej \textit{CommandFactory}, klasy \textit{ComamndHandler}, która wymagałaby dodania kolejnej instrukcji wyboru. Dodatkowo w klasie znajdowałoby się 15 metod, które nie są do końca związane z jej odpowiedzialnością. Nawet jeżeli wynieść takie metody do osobnej klasy np. \textit{CommandExecutor}, jej odpowiedzialność nadal byłaby bardzo duża.

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=16cm]{./Obrazy/commands.png}
  \caption{Diagram klas ograniczony do dostępnych komend w ramach systemu}
\end{center}
  \source{Opracowanie własne.}
\end{figure}

Robert C. Martin, autor ksiązki "\textit{Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall.}", która często bywa określana jako "biblia programistów", przedstawił zasady dobrego programowania obiektowego, określane jako SOLID. Podejście, w którym architektura komend opierałaby się na typie wyliczeniowym, stanowiłoby naruszenie przynajmniej dwóch zasad \textit{Single responsibility principle} i \textit{Open/closed principle}. Przytoczony przykład ukazuje, że przedstawione rozwiązanie jest jak najbardziej poprawne.\cite{solid}\cite{clean-code}


\subsubsection{Diagram klasy służącej do przechowywania stanu BSP}

Diagram klas (Rys. 22.) przedstawia \textit{FlightStatus}, która przechowuje dane dotyczące statusu BSP w danej chwili czasu. Jego atrybuty są dostępne do odczytu, ponieważ są typu \textit{val}, tzn. raz ustawione nie mogą zostać zmienione (odpowiednik w Javie to \textit{final}). Posiada ona jedynie metodę \textit{toJson}. Zwraca ona stan obiektu w formacie JSON, który przesyłany jest za pomocą serwisu MQTT. Klasy, które nie realizują żadnej logiki, a służą do przechowywania danych, określa się jako DTO (Data Transfer Object).

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=10cm]{./Obrazy/FlightStatus.png}
  \caption{Diagram klasy służącej do przechowywania stanu BSP}
\end{center}
  \source{Opracowanie własne.}
\end{figure}

\newpage

\subsubsection{Diagram klas ograniczony do serwisów działających w ramach komunikacji MQTT}

\begin{figure}[!htp]
\begin{center}
  \includegraphics[width=16cm]{./Obrazy/services.png}
  \caption{Diagram klas ograniczony do serwisów działających w ramach komunikacji MQTT}
\end{center}
  \source{Opracowanie własne.}
\end{figure}

  Poniższy diagram klas (Rys. 23.) reprezentuje \textit{Mqtt Services} z wcześniej przedstawionego diagramu komponentów (Rys. 20.). Z punktu widzenia \textit{FlightController} dostępne są wyłącznie metody z klasy MqttService. Najważniejsza z nich to \textit{getTopic}. Dostarcza ona abstrakt Topic-u MQTT, tj. instancje klasy \textit{Topic}. Dostarcza ona szereg metod, które umożliwiają komunikacje na wybranym Topic-u. Metoda \textit{getData} zwraca obiekt typu \textit{LiveData}, który służy w systemie android do przechowywania zmieniających się danych, za pomocą klasy \textit{Observer} dodaje się wyrażanie lambda, które zostają wywołane za każdym razem, gdy obiekt zostanie zmodyfikowany. Obiekt otrzymuje dane z brokera tylko i wyłącznie, jeżeli wcześniej włączy się subskrybuje danego Topica metoda \textit{subscribe}.

  W ramach systemu zostaną wykorzystane następujące Topic-ki MQTT:
  \begin{enumerate}
  \item Wykorzystywane wewnątrz komponentu \textit{Mqtt Services}:\begin{enumerate}
  \item Na Topic \textit{\textbf{droman/birth}} przy połączeniu z brokerem MQTT zostanie zapisany identyfikator klienta;
  \item Przy zerwaniu połączenia na \textit{\textbf{droman/lastWill}} zostanie zapisany identyfikator klienta;
  \item Do walidacji połączenia posłuży Topic \textit{\textbf{droman/validate}}. Jeżeli \textit{MqttService} nie jest w stanie opublikować na podanym Topic-u wiadomości, połączenie zostanie uznane za niepoprawne;\end{enumerate}
  \item Wykorzystywane przez serwisy \textit{ReceiveService} i \textit{UpdateService}\begin{enumerate}
  \item Na Topic \textit{\textbf{droman/status/\{numer seryjny urządzenia\}}} z pewnym interwałem czasowym są zapisywane dane określające stan BSP w formacie JSON;
  \item Urządzenie mobilne nasłuchuje na Topic-u\\ \textit{\textbf{droman/command/\{numer seryjny urządzenia\}}}, na którego wysyłane są polecenia do zrealizowania przez pojedynczy BSP.
  \item Rejestrowane obrazy są przesyłane na \textit{\textbf{droman/picture/\{numer seryjny urządzenia\}}} w formacie \textit{jpeg}.
  \end{enumerate}
\end{enumerate}
\newpage

\subsubsection{Diagram klas ograniczony do obszaru kontroli lotu}
  
Przedstawione klasy w poniższym diagramie (Rys. 24.) przedstawiają \textit{FlightController} z wcześniejszego diagramu komponentów (Rys. 20.). Wyłącznie klasy z przyrostkiem \textit{Handler} wywołują metody na udostępnionej bibliotece do obsługi drona on DJI. Podział na takie trzy klasy ma na celu zmniejszenie odpowiedzialności, zgodnie z zasadą SOLID \textit{Single responsibility principle}. \textit{FlightControlViewModel} jest ściśle powiązany z \textit{Activity} dotyczące sterowania z Andoridem. Dwa pozostałe serwisy \textit{UpdateService} i \textit{ReceiveService} służą do kolejno zapisywania i odczytywania wybranych Topic-ów.

\begin{figure}[!htp]
\begin{center}
  \includegraphics[width=16cm]{./Obrazy/handlers.png}
  \caption{Diagram klas ograniczony do obszaru kontroli lotu}
\end{center}
  \source{Opracowanie własne.}
\end{figure}

\newpage

\subsection{Środowisko uruchomieniowe}
\begin{figure}[!htp]
\begin{center}
  \includegraphics[width=14cm]{./Obrazy/dji-mini-2.jpg}
  \caption{DJI Mini 2}
  \end{center}\source{https://laptrinhx.com/
  dji-mini-2-review-same-compact-size-more-confidence-flying-3163139258/}
\end{figure}

W trakcie implementacji i testów zostaną wykorzystane następujące urządzenia:
  \begin{itemize}
  \item utextbf{Laptop}, który posłuży jako brokerserwer MQTT, a także do wykonywania skryptów wysyłających do systemy określone komendy.
  \item \textbf{Dron DJI Mini 2 wraz z kontrolerem}, czyli produkt docelowy, którego sterowanie ma umożliwiać zaimplementowany system.
  \item \textbf{Smartfon z systemem Android}, który będzie podłączony do kontrolera DJI. Aplikacja mobilna na tym urządzeniu będzie odbierała komendy z brokera MQTT, które będą definiowały sposób sterowania. Ponadto wskazana aplikacja będzie na bieżąco przesyłała status drona do serwera. Wszystko to będzie odbywało się na unikalnym topicu MQTT, który będzie zawierał numer seryjny urządzenia.
  \end{itemize}


\clearpage
\newpage
\section{Implementacja systemu}
W poniższym rozdziale zaprezentowano, wyjaśniono i uzasadnionono działanie najważniejszych fragmentów kodu systemu. W ostatnim podrozdziale zaprezentowano interfejs użytkownika na urządzeniu mobilnym.

\subsection{Wykonywanie komend}

Poniżej zaprezentowano implementacje klas (Rys. 21.), które służą do wykonywania poleceń w systemie. \textit{Command} (Kod. 1.) jest klasą, po której dziedziczą wszystkie komendy, które mogą być wykonane w systemie. Jej kluczowym elementem jest metoda \textit{exec}, która w klasach potomnych służy do zrealizowania polecenia tożsamego z jej nazwą. Jedyny argument w tej metodzie, jest typu \textit{AircraftControllers}. Jest to DTO dla wszystkich obiektów, które są wymagane do zrealizowania komendy.

Jednym z przykładów jest klasa \textit{StartMotorsCommand} (Kod. 2.), która odpowiada, zgodnie z jej nazwą, za wystartowanie silników. W linii nr 7 za pomocą \textit{AircraftControllers} wyciągany jest ostatni status BSP. Następnie w linii nr 6 dokonywane jest sprawdzenie, czy BSP nie lata i nie ma włączonych silników, jeżeli nie, to za pomocą klasy \textit{FlightController} z biblioteki DJI uruchamiane są silniki. W przeciwnym wypadku zwracany jest stosowny komunikat (linia nr 13).



\begin{lstlisting}[language=Java, caption=Klasa \textit{Command}]
  abstract class Command(val type: String, val completionCallback: CommonCallbacks.CompletionCallback<DJIError>) {
    abstract fun exec(aircraftControllers: AircraftControllers)

    companion object {
        const val TAG = "Command"
    }
}
\end{lstlisting}
\source{Badania własne.}

\begin{lstlisting}[language=Java, caption=Klasa \textit{StartMotorsCommand}]
class StartMotorsCommand(completionCallback : CommonCallbacks.CompletionCallback<DJIError>) : Command(type, completionCallback) {
  companion object {
      const val type = "start_motors"
  }

  override fun exec(aircraftControllers: AircraftControllers) {
      val status = aircraftControllers.statsHandler.getLastStatus()
      if (!status.isFlying && !status.motorsOn) {
          aircraftControllers.flightController.turnOnMotors(
              completionCallback
          )
      } else {
          FeedbackUtils.setResult("Forbidden state can't start motors", TAG)
      }
  }
}
\end{lstlisting}
\source{Badania własne.}

\newpage
Samo wykonywanie metody \textit{exec} ogranicza się w klasie \textit{CommandHandler} do 3 linii kodu (Kod. 3.), jest to korzyść odniesiona dzięki dobrze dobranej architekturze. Pozostałe ciało klasy zostanie omówione na późniejszych stronach.


\begin{lstlisting}[language=Java, caption=Fragment kodu z CommandHandler]
private val commandObserver = Observer<Command> {
  it.exec(aircraftControllers)
}
\end{lstlisting}
\source{Badania własne.}

\textit{CommandFactory} (Kod. 4.) zgodnie ze wzorcem projektowym \textit{Factory} (pl. \textit{Fabryka}), odpowiada za tworzenie kolejnych instancji klasy \textit{Command}. Metoda \textit{getCompletionCallback} dostarcza uniwersalny obiekt do obsługi poleceń wykonywanych za pomocą metod z biblioteki DJI. Najważniejsza jest jednak w niej metoda \textit{from}. Dla przedstawionej wartości tekstowej w formacie JSON zwraca ona instancje odpowiedniej klasy. W linii nr 10 za pomocą biblioteki \textit{Gson} tworzony jest obiekt \textit{JsonObject}, na podstawie zawartości zmiennej \textit{value}. Jeżeli wartość tekstowa nie jest w ogóle w formacie JSON, zostanie rzucony wyjątek, którego obsługa polega na zwróceniu instancji \textit{UnrecognizedCommand} (linia nr 15), zgodnie z wcześniej przyjętą zasadą, która mówi, że zwrócenie wartości \textit{null} jest złą praktyką. Metoda \textit{createCommand} na podstawie dostarczonych argumentów zwraca odpowiednią instancję klasy \textit{Command}. To w jej ciele zostanie dokonana zmiana, jeżeli do systemu zostanie dodana kolejna komenda. Klasa ta może rzucać wyjątki (linia nr 23). Jest to spowodowane tym, że w momencie tworzenia niektórych komend, które zawierają dodatkowe parametry, jak np. współrzędne, dokonywana jest walidacja ich poprawności. Jeżeli te wartości będą niepoprawne, zostanie rzucony wyjątek, ponieważ nie można dopuścić do wykonania polecenia z niepoprawnymi parametrami. Również on jest obsługiwany w liniach nr 13-16.


\begin{lstlisting}[language=Java, caption=Klasa \textit{CommandFactory}]
class CommandFactory {
  companion object {
      const val TAG = "CommandFactory"
  }

  private val gson: Gson = Gson()

  fun from(value: String): Command {
      return try {
          val jsonObject = gson.fromJson(value, JsonObject::class.java)
          val missionType = jsonObject.get("type").asString
          createCommand(missionType, jsonObject)
      } catch (e: Exception) {
          FeedbackUtils.setResult(e.toString(), level = LogLevel.ERROR, tag = TAG)
          UnrecognizedCommand(value, getCompletionCallback(UnrecognizedCommand.type))
      }
  }

  private fun getCompletionCallback(type: String): CompletionCallbackImpl<DJIError> {
      //returns commpletion callback object
  }

  @Throws(Throwable::class)
  private fun createCommand(type: String, jsonObject: JsonObject): Command {
      return when (type) {
          StartGoHomeCommand.type -> {
              StartGoHomeCommand(getCompletionCallback(StartGoHomeCommand.type))
          }
          LandCommand.type -> {
              LandCommand(getCompletionCallback(LandCommand.type))
          }
          ShootPhotoCommand.type -> {
              ShootPhotoCommand(getCompletionCallback(ShootPhotoCommand.type))
          }
          // ...
          //and more cases
          // ..
          PauseWaypointCommand.type -> {
              PauseWaypointCommand(getCompletionCallback(PauseWaypointCommand.type))
          }
          else -> {
              UnrecognizedCommand(
                  jsonObject.toString(),
                  getCompletionCallback(UnrecognizedCommand.type)
              )
          }
      }
  }

}
\end{lstlisting}
\source{Badania własne.}


\subsection{Obsługa MQTT}
 W tej sekcji zaprezenotwano klasy związane z obsługą komunikacji za pomocą MQTT. Na poziomie najbliższym komponentowi \textit{FlightController} (Rys. 20.) ważne są wyróżnienia klasy \textit{MqttService} (Kod. 6.) i jej klasa wewnętrzna \textit{Topic} (Kod 5.). 
 
 Ta wewnętrzna klasa dostarcza metody, które umożliwiają komunikacje na wybranych Topic-ach z minimalnym wysiłkiem dla programisty. Jako argument w swoim konstruktorze przyjmuje ścieżkę Topica MQTT. Dzięki temu metody odpowiedzialne za publikowanie wiadmości MQTT (linie nr 2-8) ograniczone są do jednego argumentu, czyli ich treści. Pozostałe metody, jak np. włączenia subskrybcji(linie 14-15), sprawdzenia czy dany Topic jest subskrybowany (10-12) czy pobierania wiadomości nie potrzebują żadnych dodatkowych argumentów. Klasa ta też jest bardzo krótka ponieważ wszystkie skomplikowane operacja są wykonywane przez \textit{MqttService}. W której to (Kod. 6.) należy wyróżnić dwie istotne zmienne \textit{subscribedTopics} i \textit{messagesArrived} (linie 9-10). Pierwsza z nich to zbiór wartości tekstowych, konkretnie ścieżek, które są subskrybowane przez klienta Mqtt. Kolejne wartości są dodawnane do niego wraz z rozpoczęciem subskrybcji danego Topica w metodzie \textit{subscribe} (linie 48-54), a usuwane w momencie zakończenia subskrybcji metodą \textit{unsubscribe} (linie 40-41).

 Przy opisywaniu zmiennej \textit{messagesArrived} należy zwrócić uwagę na wyrażenie lambda \textit{messageArrivedFun}(linie 16-23), które jest wykonywane za każdym razem gdy klient MQTT otrzyma wiadomość. W jego ciele najistotniejsza jest linia nr 20, w trakcie której to za pomocą metody \textit{getTopicData} pobierany jest obiekt \textit{LiveData<MqttMessage>} dotyczący danego Topica, a następnie zapisywana jest nowa wiadomość za pomocą metody \textit{postValue}. Analizując jeszcze metodę \textit{getTopicData} należy zwrócić uwagę na linię nr 37, w której to z wcześniej wspomnianej mapy \textit{messagesArrived} pobierana jest metodą \textit{getOrPut} wartość dla klucza równego ścieżce Topic-a, jeżeli w mapie nie ma wartości dla podanego klucza to do mapy dodawana jest nowa para o wartości \textit{MutableLiveData()}. W ten sposób w \textit{messagesArrived} znajdują się pary w których klucz to ścieżka danego Topic-a, który istnieje w systemie, a wartość to obiekt \textit{LiveData<MqttMessage>} z ostatnią otrzymaną wiadmością.



 \begin{lstlisting}[language=Java, caption=Klasa wewnętrzna \textit{Topic}]
  class Topic(private val value: String, private val mqttService: MqttService) {
    suspend fun publish(payload: ByteArray): Result<IMqttDeliveryToken> {
        return mqttService.publish(MqttDto(value, payload))
    }
  
    suspend fun publish(payload: String): Result<IMqttDeliveryToken> {
        return mqttService.publish(MqttDto(value, payload))
    }
  
    fun isSubscribed(): Boolean {
        return mqttService.getSubscribed().contains(value)
    }
  
    suspend fun subscribe(): Result<IMqttToken> {
        return mqttService.subscribe(value)
    }
  
    suspend fun unsubscribe(): Result<IMqttToken> {
        return mqttService.unsubscribe(value)
    }
  
    fun getData(): LiveData<MqttMessage> {
        if (!isSubscribed()) {
            Log.w(TAG, "getData without subscribing topic $value")
        }
        return mqttService.getTopicData(value)
    }
  
    fun getValue(): String {
        return value
    }
  }
  
  \end{lstlisting}
\source{Badania własne.}



\begin{lstlisting}[language=Java, caption=Klasa \textit{MqttService} ]
class MqttService(
  context: Context,
  mqttCredentials: MqttCredentials,
  lastWill: MqttDto? = null,
  birth: MqttDto? = null,
  keepAliveInterval: Int = GlobalConfig.KEEP_ALIVE_INTERVAL,
) {

  private val subscribedTopics: MutableSet<String> = HashSet()
  private val messagesArrived: HashMap<String, MutableLiveData<MqttMessage>> = HashMap()

  private val connectionLostFun: (throwable: Throwable) -> Unit = { 
    //... reconnect and resubscribe topics}
  private val deliveryCompleteFun: (token: IMqttDeliveryToken) -> Unit = {//... }

  private val messageArrivedFun: (topic: String, message: MqttMessage) -> Unit =
      { topic, message ->
          if (subscribedTopics.contains(topic)) {
              Log.d(TAG, "Receive message: $message from topic: $topic")
              getTopicData(topic).postValue(message)

          } else { //... some log info }
      }

  private val mqttRepository = MqttRepository(//... init with values above)

  init {
      this.let { service ->
          DjiApplication.mainScope.launch(Dispatchers.IO) {
              birth?.let { service.publish(it) }
          }
      }
  }

  private fun getTopicData(topic: String): MutableLiveData<MqttMessage> {
      return messagesArrived
          .getOrPut(topic) { MutableLiveData() }
  }

  private suspend fun unsubscribe(value: String): Result<IMqttToken> {
      val res = mqttRepository.unsubscribe(value)
      if (res.isSuccess) {
          subscribedTopics.remove(value)
      }
      return res
  }

  private suspend fun subscribe(value: String): Result<IMqttToken> {
      val res = mqttRepository.subscribe(value)
      if (res.isSuccess) {
          subscribedTopics.add(value)
      }
      return res
  }

  private fun getSubscribed(): Set<String> {
      return subscribedTopics
  }

  private suspend fun publish(data: MqttDto): Result<IMqttDeliveryToken> {
      return mqttRepository.publish(data)
  }

  fun getTopic(value: String): Topic {
      return Topic(value = value, this)
  }

  suspend fun destroy() {
      mqttRepository.destroy()
  }

  suspend fun validate(): Boolean {
      return mqttRepository.publish(MqttDto(ETopic.VALIDATE, "validate" + UUID.randomUUID()))
          .isSuccess
  }
  class Topic(private val value: String, private val mqttService: MqttService) {
    //... inner class
  }
  
}
\end{lstlisting}
\source{Badania własne.}

\subsection{Kontrolowanie BSP}

Robert C. Martin w swojej książce "\textit{Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall.}" mówi między innymi o tym, że ciało klasy powinno być jak najkrótsze, nie tylko pod względem liczby linijek kodu, ale również odpowiedzialności \cite{clean-code}, dlatego też odpowiedzialności w ramach kontrolowania BSP podzielono na 3 klasy \textit{CameraHandler}, \textit{StatusHandler} i \textit{CommandHandler}. Cyklem ich życia zarządza \textit{FlightControlViewModel} (Kod. 7.), który jest ściśle związany z aktywnością Andorida \textit{FlightControlActivty}. W jego konstruktorze (linie 14-28) inicjowane są klasy na które została podzielona odpowiedzialność. Nie udało sie wynieść tego do \textit{FlightControlViewModelFactory} ponieważ wymagają one w swoim ciele kontekstu Androida, który nie jest dostępny na poziomie \textit{ViewModelProvider.Factory}. \cite{clean-code}

\begin{lstlisting}[language=Java, caption=Klasa \textit{FlightControlViewModel}]
class FlightControlViewModel(
private var updateService: UpdateService,
private var receiveService: ReceiveService
) : ViewModel() {

private var cameraHandler: CameraHandler? = null
private var statusHandler: StatusHandler? = null
private var commandHandler: CommandHandler? = null

companion object {
    const val TAG = "FlightControlViewModel"
}

init {
    DjiApplication.aircraftInstance?.let { aircraft ->
        FeedbackUtils.setResult("Aircraft found", LogLevel.DEBUG, TAG)
        statusHandler = StatusHandler(aircraft.flightController, viewModelScope, updateService)
        cameraHandler = CameraHandler(aircraft.camera, viewModelScope, updateService)
        commandHandler = CommandHandler(
            cameraHandler!!,
            statusHandler!!,
            aircraft.flightController,
            receiveService
        )
    } ?: run {
        FeedbackUtils.setResult("Aircraft not found", LogLevel.WARN, TAG)
    }
}

fun destroy() {
    commandHandler?.destroy()
    cameraHandler?.destroy()
    statusHandler?.destroy()
}
}
\end{lstlisting}
\source{Badania własne.}

Klasa \textit{StatusHandler} odpowiada za zapisywanie statusu BSP co pewien interwał czasowy. Obiekt \textit{flightController} 10 razy na sekunde wywołuje wyrażenie lambda przekazane przez \textit{setStateCallback} w liniach nr 16-28. Żeby ograniczyć liczbę przesyłanych wiadomości MQTT wprowadzono mechanizm, który przy każdym wywołaniu wyrażenia, zwiększa zmienną \textit{lastUpdateCnt} i gdy osiągnie ona wartość określoną przez \textit{GlobalConfig.STATE\_RATE\_LIMIT} wysyła, następuje jej wyzerowanie, a następnie wysłanie wiadmości MQTT. \textit{setStateCallback} działa na obiekcie klasy \textit{FlightControllerState} z biblioteki DJi, dlatego też dokonujemy przekształcenia na  klasę z tego systemu \textit{FlightStatus}, m.in. dlatego że udostępnia ona metodę do generowania statusu, jako wartości tekstowej w formacie JSON. Dodatkowo w klasie przechowywany jest ostatni status BSP (linia nr 19).

\begin{lstlisting}[language=Java, caption=Klasa \textit{StatusHandler}]
class StatusHandler(
  private val flightController: FlightController,
  viewModelScope: CoroutineScope,
  updateService: UpdateService
) {
  companion object {
      const val TAG = "StatusHandler"
  }

  private var lastUpdateCnt = 0
  private lateinit var lastStatus: FlightStatus
  private var _status: MutableLiveData<FlightStatus> = MutableLiveData()
  var status: LiveData<FlightStatus> = _status

  init {
      flightController
          .setStateCallback { state ->
              viewModelScope.launch(Dispatchers.IO) {
                  lastStatus = FlightStatus.gen(state)
                  if (lastUpdateCnt == 0) {
                      updateService.saveCallback(lastStatus)
                  }
                  _status.postValue(lastStatus)
                  lastUpdateCnt++
                  lastUpdateCnt %= GlobalConfig.STATE_RATE_LIMIT
              }
          }
  }


  fun getLastStatus(): FlightStatus {
      return status.value!!
  }

  fun destroy() {
      flightController.setStateCallback(null)
  }
}
\end{lstlisting}
\source{Badania własne.}

Klasa \textit{CameraHandler} (Kod. 9.) odpowiada za operację związane z aparatem BSP. Udostępnia ona jedną publiczną metodę \textit{shootPhoto}, której wykonanie wywołuje zdjęcie (linie nr 36-41). W konstruktorze, tak jak we wcześniejszej klasie, na każde wygenerowanie obrazu ustawiane jest wyrażenie lambda (linie nr 15-33), które pobiera w najwyższej możliwej rozdzielczości obraz i przesyła go za pomocą \textit{UpdateService}. Ponieważ nie wszystkie drony od DJI wspierają tryb przesyłania obrazu w wysokiej jakości, metoda \textit{initCheckingIfSupportMediaDownloadMode} sprawdza, czy ustawienie takiego trybu pracy kamery jest możliwe i ustawia odpowiednią wartość zmiennej \textit{supportDownloadMediaMode}. Na koniec warto zwrócić uwagę na \textit{MediaFile.getSusPreview}. Jest to rozszerzenie metody, które zwraca obraz zrobionego zdjęcia w postaci obiektu \textit{Bitmap}. Ponieważ jest to metoda asynchroniczna, nie należy przejmować się jej wstrzymywaniem (linia nr 57) w oczekiwaniu na wczytanie obrazu w postaci bitmapy.
  
\begin{lstlisting}[language=Java, caption=Klasa \textit{CameraHandler}]
class CameraHandler(
private val camera: Camera,
viewModelScope: CoroutineScope,
updateService: UpdateService
) {
companion object {
    const val TAG = "CameraHandler"
}

private var supportDownloadMediaMode = false

init {
    initCheckingIfSupportMediaDownloadMode()

    camera.setMediaFileCallback {
        if (supportDownloadMediaMode) {
            viewModelScope.launch(Dispatchers.IO) {
                it.getFullView()
                    ?.let { byte -> updateService.savePicture(byte) }
            }
        } else {
            viewModelScope.launch(Dispatchers.IO) {
                it.getSusPreview()?.let { it1 -> updateService.savePicture(it1) }
                    ?: run {
                        FeedbackUtils.setResult(
                            "Cannot get preview",
                            level = LogLevel.ERROR,
                            tag = TAG
                        )
                    }
            }
        }
    }
}

fun shootPhoto() {
    camera.startShootPhoto(
        CompletionCallbackImpl<DJIError>(TAG,
            { FeedbackUtils.setResult("Success shoot photo", TAG) })
    )
}

fun initCheckingIfSupportMediaDownloadMode() { //...  }

private fun setBackToShootPhotoMode() { //...  }

private suspend fun MediaFile.getSusPreview(): Bitmap? {
    if (this.preview != null) {
        return this.preview
    }
    this.fetchPreview(
        CompletionCallbackImpl<DJIError>(TAG,
            { FeedbackUtils.setResult("Success fetching photo preview", TAG) })
    )
    var inc = 0
    while (this.preview == null && inc < 200) {
        delay(100)
        inc++
    }
    return this.preview
}

private suspend fun MediaFile.getFullView(): Bitmap? {
    val destDir =
        File("${Environment.getExternalStorageDirectory().path}/${GlobalConfig.FOLDER_FOR_HQ_MEDIA}/")
    val downloadHandler = DownloadListenerImpl<String>(camera)
    this.fetchFileData(destDir, this.fileName, DownloadListenerImpl<String>(camera))
    return downloadHandler.getBitmap()
}

fun destroy() {
    camera.setMediaFileCallback(null)
}
}
\end{lstlisting}
\source{Badania własne.}

Ostatnia klasa \textit{CommandHandler} (Kod. 10.) odpowiada za realizowanie otrzymywanych komend przez BSP. Ze względu na wyniesie logiki wykonywania poleceń do klasy \textit{Command}, klasa ta mocno skróciła swoje ciało i dzięki temu jest bardziej czytelna. \textit{commandLiveData} jest to obiekt \textit{LiveData<Command>}, który jest wynikiem subskrybowania Topic-u przeznaczonego do przesyłania poleceń i odpowiedniego prze mapowania tych danych przez \textit{ReceiveService}. Bardzo istotne w tej klasie jest zarządzenie cyklem życia obiektów typu \textit{Observer}. Cykl wykonywania wyrażeń zawartych w \textit{commandObserver} i \textit{statusObserver} rozpoczynany jest w konstruktorze tej klasy (linie nr 35-36) i zakańczany w momencie wywoływania metody \textit{destroy} (linie 49-56). Dodatkowo w tych samych miejscach (linie nr 37-40 i 53-55) włączany i wyłączany jest tryb symulacji drona na podstawie \textit{GlobalConfig.SIMULATOR\_MODE}.

\begin{lstlisting}[language=Java, caption=Klasa \textit{CommandHandler}]
class CommandHandler(
  cameraHandler: CameraHandler,
  private val statsHandler: StatusHandler,
  private val flightController: FlightController,
  receiveService: ReceiveService,
) {
  companion object {
      const val TAG = "MissionHandler"
  }
  private val waypointMissionOperator = MissionControl.getInstance().waypointMissionOperator
  private val waypointMissionOperatorListener = WaypointMissionOperatorListenerImpl()

  private val commandLiveData: LiveData<Command> = receiveService.getCommand()


  private val commandObserver = Observer<Command> {
      it.exec(aircraftControllers)
  }

  private val aircraftControllers = AircraftControllers(
      cameraHandler,
      statsHandler,
      flightController,
      waypointMissionOperator
  )
  private val statusObserver = Observer<FlightStatus> {
      if (it.isLandingConfirmationNeeded) {
          flightController.confirmLanding(
              CompletionCallbackImpl<DJIError>( //... feedback flow )
          )
      }
  }

  init {
      commandLiveData.observeForever(commandObserver)
      statsHandler.status.observeForever(statusObserver)
      if (GlobalConfig.SIMULATOR_MODE) {
          flightController.simulator
              .start( // ... initializationData )
      }
      setMaxFlightHeight(flightController)
      setMaxFlightRadius(flightController)
      waypointMissionOperator.addListener(waypointMissionOperatorListener)
  }

 fun setMaxFlightHeight(flightController: FlightController) { //...}
 fun setMaxFlightRadius(flightController: FlightController) { //...}

  fun destroy() {
      commandLiveData.removeObserver(commandObserver)
      waypointMissionOperator.removeListener(waypointMissionOperatorListener)
      statsHandler.status.removeObserver(statusObserver)
      if (GlobalConfig.SIMULATOR_MODE) {
          flightController.simulator.stop( //... feedback flow )
      }
  }
}
\end{lstlisting}
\source{Badania własne.}

\subsection{Interfejs użytkownika}
 Graficzny interfejs użytkownika ograniczony jest do dwóch aktywności na urządzeniu mobilnym. 
 
 Pierwsza (Rys. 27.) przedstawia część interfejsu umożliwiającą logowanie do brokera MQTT. Po wpisaniu danych należy sprawdzić połączenie za pomocą przycisku \textit{CHECK CONNECTION}. Dopiero przy poprawnie zwalidowanym połączeniu możliwe jest przejście do kolejnej aktywności za pomocą drugiego przycisku \textit{START}.

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=16cm]{./Obrazy/droman2.jpg}
  \caption{Zrzut ekranu przedstawiający widok do wprowadzania danych autoryzujących}
  \end{center}
  \source{\myurl{https://www.instalki.pl/images/newsy/03-2022/Bayraktar_TB2_ukraina.jpg}}
\end{figure}

Druga, właściwa aktywność (Rys. 28.), przedstawia wszystkie elementy umożliwiające sterowanie ręczne dronem w tym logi wykonywanych operacji. W trakcie właśnie tego widoku trwa komunikacja drona z serwerem MQTT, ale nadal można używać kontrolera jak przy klasycznym użytkowaniu.

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=14cm]{./Obrazy/droman1.jpg}
  \caption{Zrzut ekranu przedstawiający widok do kontroli BSP}
  \end{center}
  \source{\myurl{https://www.instalki.pl/images/newsy/03-2022/Bayraktar_TB2_ukraina.jpg}}
\end{figure}
  
\clearpage
\newpage
\section{Testy systemu oraz prezentacja użycia na wybranym case study}
W poniższym rozdziale zaprezentowano, omówiono i przeprowadzono testy systemu, które świadczą o jego poprawnym działaniu.

\subsection{Testy na platformie Andorid}

W kontekście testowania oprogramowania na platformie Android można wyróżnić dwa
rodzaje testów:
\begin{itemize} 
  \item \textbf{androidTest} - Testy, które są uruchamiane na rzeczywistych lub wirtualnych urządzeniach z systemem Android. Obejmują one m.in. testy integracyjne. Szczególnie takie, w których sama JVM nie może sprawdzić działania kodu. W ramach tego rodzaju testów przetestowano serwisy odpowiedzialne za komunikacje za pomocą MQTT. Konieczność ta jest spowodowana tym, że są to operacje asynchroniczne, które do swojego wykonania korzystają z narzędzi do zarządzania cyklem życia obiektów dostarczanych przez system Android, dlatego muszą być wykonane w ramach tego kontekstu.
  \item \textbf{test} - Klasyczne testy jednostkowe, które mogą być uruchamiane na lokalnej maszynie JVM. W ramach tych testów przetestowano m.in. mapowanie obiektów JSON na klasy wykorzystywane do wykonywania poszczególnych komend (klasa \textit{pl.edu.wat.droman.data.model.command.Command}) na urządzeniu.
\end{itemize}

\newpage
\subsection{Testy jednostkowe}
W ramach testów jednostkowych przetestowano klasę \textit{CommandFactory}, która odpowiada za generowanie obiektów klas komend, na podstawie wartości tekstowej w formacie JSON, które są w późniejszym etapie wykonywane za pomocą klasy \textit{CommandHandler}.

\subsubsection{Test tworzenia komendy \textit{TakeOffCommand}, za pomocą \textit{CommandFactory}}
Poniższy test (Kod. 11.) sprawdza trzy warunki: 
\begin{itemize}
  \item Czy wygenerowana komenda przez CommandFactory faktycznie istnieje, a nie jest przypadkiem wartością \textit{null}?
  \item Czy klasa wygenerowanego obiektu jest klasą \textit{TakeOffCommand}?
  \item Czy wartość parametru \textit{type} w obiekcie jest równa stałej \textit{TakeOffCommand.type}?
\end{itemize}

\begin{lstlisting}[language=Java, caption=Test tworzenia komendy \textit{TakeOffCommand}\, za pomocą \textit{CommandFactory}]
  @Test
  fun testMappingToTakeOffCommand() {
      //given
      val commandFactory = CommandFactory()
      val missionValue = "{\"type\": \"take_off\"}"
      //then
      val command = commandFactory.from(missionValue)

      //expect
      assertNotNull(command)
      assertEquals(TakeOffCommand::class.java,command.javaClass)
      assertEquals(TakeOffCommand.type, command.type)
  }
\end{lstlisting}
\source{Badania własne.}



\newpage
\subsubsection{Test tworzenia komendy \textit{UploadWaypointCommand}, za pomocą \textit{CommandFactory}}
Poniższy przykładowy test (Kod. 12.), w którym niestety nie można przetestować bezpośrednio wartości m.in. współrzędnych, ponieważ dostęp do nich jest chroniony przez mofikatoru dostępu, a biblioteka JUnit4 nie umożliwia dostępu do obiektów chronionych. Warto dodać, że inne frameworki, jak np. Spock, już takie rzeczy umożliwiają. Sam test służy do upewnienia się, że wartość tekstowa została zmapowana na poprawny obiekt, a w trakcie jego tworzenia nie został wywołany żaden wyjątek.

\begin{lstlisting}[language=Java, caption=Test tworzenia komendy \textit{UploadWaypointCommand}]
  @Test
  fun testMappingToUploadMissionCommand() {
      //given
      val commandFactory = CommandFactory()
      val missionValue = "{\n" +
              "            \"type\": \"upload_waypoint_mission\",\n" +
              "            \"finished_action\": \"NO_ACTION\",\n" +
              "            \"auto_flight_speed\": 0.01,\n" +
              "            \"max_flight_speed\": 0.5,\n" +
              "            \"heading_mode\": \"AUTO\",\n" +
              "            \"waypoints\": [\n" +
              "                {\n" +
              "                    \"attitude\": 1.0,\n" +
              "                    \"longitude\": 1.0,\n" +
              "                    \"latitude\": 1.0\n" +
              "                },\n" +
              "                {\n" +
              "                    \"attitude\": 1.0,\n" +
              "                    \"longitude\": 1.0,\n" +
              "                    \"latitude\": 1.0\n" +
              "                },\n" +
              "                {\n" +
              "                    \"attitude\": 1.0,\n" +
              "                    \"longitude\": 1.0,\n" +
              "                    \"latitude\": 1.0\n" +
              "                }\n" +
              "            ]\n" +
              "        }"

      //then
      val command = commandFactory.from(missionValue)

      //expect
      assertNotNull(command)
      assertEquals(UploadWaypointCommand.type, command.type)
      assertEquals(UploadWaypointCommand::class.java,command.javaClass)
  }
\end{lstlisting}
\source{Badania własne.}

\subsubsection{Test tworzenia komendy \textit{UnrecognizedCommand} w przypadku nierozpoznania wartości za pomocą \textit{CommandFactory}}
Jeżeli z jakiegoś powodu \textit{CommandFactory} nie będzie mógł zmapować wartości tekstowej, bo np. zostane podany zły typ, zwróci on obiekt \textit{UnrecognizedCommand}. Nie zwaraca wartości \textit{null}, ponieważ jest to uznawane za złą praktykę, a język programowania Kotlin wręcz do tego przymusza. Poniższy test (Kod. 13.) sprawdza wspominany przypadek.

\begin{lstlisting}[language=Java, caption=Test tworzenia komendy \textit{UnrecognizedCommand}]
  @Test
  fun testMappingToFailUploadMissionCommand() {
      //given
      val commandFactory = CommandFactory()
      val missionValue = "{\"type\": \"dsadas\"}"
      //then
      val command = commandFactory.from(missionValue)

      //expect
      assertNotNull(command)
      assertEquals(UnrecognizedCommand::class.java,command.javaClass)
      assertEquals(UnrecognizedCommand.type, command.type)
  }
\end{lstlisting}
\source{Badania własne.}

\subsection{Testy na środowisku uruchomieniowym}
W ramach testów przeprowadzono również wcześniej wspomniane testy na środowisku Android. Ich celem było przetestowanie komunikacji z brokerem MQTT za pomocą zaimplementowanych klas \textit{MqttService}, \textit{MqttRepository} i \textit{ReceiveServiceTest}

\subsubsection{Testy klasy \textit{MqttRepository}}
Przed uruchomieniem pojedynczych testów, JUnit uruchamia metodę z adnotacją \textit{@Before} (Kod. 14.). W tym przypadku metoda ta ustawia zmienne w klasie dotyczące kontekstu Androida i danych logowania do brokera MQTT. Warto zaznaczyć, że dane logowania nie są zapisane nigdzie w repozytorium, a są wczytywane na etapie budowania aplikacji z pliku \textit{gradle.properties}, który znajduje się w folderze na środowisku, na którym jest budowana aplikacja.

Poniżej przedstawiono dwa przykładowe testy. Pierwszy z nich (Kod. 15.) publikuje na wybranym Topic-u losową wartość tekstową. W asercjach sprawdzane jest, czy obiekt \textit{Result} jest uznana za sukces i czy opublikowana wiadomość z \textit{IMqttDeliveryToken} jest równa wygenerowanej wiadomości.

Drugi test (Kod. 16.) sprawdza, czy obiekt \textit{Result} jest uznany za niepowodzenie, jeżeli wiadomość zostanie opublikowana na nieistniejący broker MQTT.


\newpage
\begin{lstlisting}[language=Java, caption=Inicjalizowanie wartosci dla wszystkich testów w \textit{MqttRepositoryTest}]
@Before
fun init() {
    appContext = InstrumentationRegistry.getInstrumentation().targetContext
    val metadata: Bundle = appContext.packageManager.getApplicationInfo(
        appContext.packageName,
        PackageManager.GET_META_DATA
    ).metaData

    password = metadata.getString("mosquitto.password")!!
    user = metadata.getString("mosquitto.user")!!
    uri = "tcp://" + metadata.getString("mosquitto.ip")
}
\end{lstlisting}
\source{Badania własne.}

\begin{lstlisting}[language=Java, caption=Test publikowania losowej wiadmości MQTT]
@Test
fun publishExampleData() = runBlocking {
    //given
    val mqttRepository = MqttRepository(
        context = appContext,
        mqttCredentials = MqttCredentials(uri, clientID, user, password)
    );
    val message = "message:" + UUID.randomUUID()

    //then
    val res = mqttRepository.publish(MqttDto(ETopic.TEST, message))

    //except
    assertTrue(res.isSuccess)
    assertEquals(message, res.getOrThrow().message.toString())
}
\end{lstlisting}
\source{Badania własne.}

\begin{lstlisting}[language=Java, caption=Test publikowania wiadomości na nieistniejący broker MQTT]
@Test
fun publishWithFailureExampleData() = runBlocking {
    //given
    val mqttRepository = MqttRepository(
        context = appContext,
        mqttCredentials = MqttCredentials("tcp://192.168.1.13", clientID, user, password)
    );
    val message = "message:" + UUID.randomUUID()

    //then
    val res = mqttRepository.publish(MqttDto(ETopic.TEST, message))

    //except
    assertTrue(res.isFailure)
}
\end{lstlisting}
\source{Badania własne.}



\subsubsection{Testowanie klasy \textit{MqttService}}


Klasa \textit{MqttService} zarządza Topic-ami MQTT. Na podstawie podanej ścieżki dla transmisji MQTT, dostarcza ona łatwy w obsłudze abstrakt (klasa \textit{MqttService.Topic}). Można na nim wykonywać opcje publikowania i subskrybowania wiadomości. Subskrypcja polega na przekazywaniu danych przez obiekt \textit{LiveData} z systemu Android. Inicjowanie zmiennych w tej klasie odbywa się w taki sam sposób jak w \textit{MqttRepositoryTest} (Kod. 14.)

Przykładowy test (Kod. 17.) sprawdza czy pobrana wiadomość za pomocą klasy \textit{Topic} jest równa wcześniej zapisanej na tym Topicu. W linii nr 8 pobierana jest instancja klasy \textit{Topic} o ścieżce \textit{text}. Następnie w liniach 8-9 na pobrany Topic włączana jest jego subskrybcja i publikowana jest wiadomość o losowej treści. Za pomocą rozszerzenia metody \textit{getOrAwaitValue} w języku Kotlin (ang. Extension Function) pobierana jest wartość a obiektu klasy \textit{LiveData}. Rozszerzenie to czeka przez 5 s., aż do podanego obiektu zostanie zapisana nowa dana, albo rzuca wyjątek. W ten sposób zmienna \textit{result} przyjmuje wartość typu \textit{String} a nie \textit{LiveData<String>}.


\begin{lstlisting}[language=Java, caption=Test pobierania danych za pomocą \textit{MqttService}]
  @Test
  fun getData() {
    //given
    val message = "message:" + UUID.randomUUID()
    val topicVal = "test"

    //then
    val topic = mqttService.getTopic(topicVal)
    runBlocking {
        topic.subscribe()
        topic.publish(message)
    }
    val result = topic.getData().getOrAwaitValue(time = 5).toString()

    //except
    Assert.assertEquals(message, result)
  }
\end{lstlisting}
\source{Badania własne.}

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=12cm]{./Obrazy/MqttTestResult.png}
  \caption{Wynik testów MqttRepository}
\end{center}
\source{Badania własne.}
\end{figure}

\subsubsection{Testy klasy \textit{ReceiveService}}

Ostatni przedstawiony test (Kod. 18.) dotyczy klasy \textit{ReceiveService}. W linii nr 7 na wskazany Topic, który jest przeznaczony do przesyłania komend, publikowane jest polecenie zrobienia zdjęcia w formacie JSON. \textit{ReceiveService} nasłuchuje na wspomnianym Topic-u i zwraca dane za pomocą klasy \textit{LiveData}. Dostęp do tego obiektu uzyskuje się w linii nr 8, za pomocą metody \textit{getCommand}. Następnie ponownie wykorzystując \textit{getOrAwaitValue} z klasy \textit{LiveData} wyciągany jest obiekt klasy \textit{Command}. Test polega na porównaniu parametru \textit{type} z uzyskanego obiektu z wartością \textit{ShootPhotoCommand.type}

\begin{lstlisting}[language=Java, caption=Test pobierania komend przez \textit{ReceiveService}]
  @Test
  fun getMission() = runBlocking {
      //given
      val message = "{\"type\":\"" + ShootPhotoCommand.type + "\"}"

      //then
      commandTopic.publish(message)
      val res = receiveService.getCommand().getOrAwaitValue(time = 5)


      //except
      assertEquals(ShootPhotoCommand.type, res.type)
  }
\end{lstlisting}
\source{Badania własne.}

\subsection{Testy end-to-end}

Testy end-to-end to rodzaj testów automatycznych w którym sprawdzane jest działanie całego systemu, bez znajmości jego budowy. Test jest dokonywany za pomocą wystawionego interfesju. W ramach systemu przygotowano dwa skrypty w języku Python, które umożliwiają ich przeprowadzenie. 

\subsubsection{Publikowanie na Topic-u przeznaczonym do przesyłania komend} 

Przedstawiony skrypt (Kod. 19.) umożliwia w prosty sposób przesyłanie komend do urządzenia końcowego. Dodatkowo w ramach skryptu zostały udostępnione dwie sekwencje \textit{test} i \textit{test\_with\_take\_off}. Pierwsza z nich wykonuje trzy następujące po sobie komendy, które odpowiadają kolejno za:
\begin{itemize}
  \item uruchomienie silników;
  \item zrobienie zdjęcia;
  \item wyłącznie silników.
\end{itemize}
Druga z nich wykonuje dodatkowo wystartowanie, tj. uniesienie się na wysokość 1,4 metra i wylądowanie. Test oznaczony jako \textit{test} w trakcie implementacji stanowił szybką weryfikacje działania, nawet w zamkniętym pomieszczeniu.

\newpage
\begin{lstlisting}[language=Python, caption=Skrypt przeznaczony do publikowania na nasłuchiwanym przez urządzenie latające Topic-u komend.]
  if __name__ == '__main__':
  client = mqtt.Client()
  client.username_pw_set(username=USERNAME, password=PASSWORD)
  client.on_connect = on_connect
  client.connect(MQTT_SERVER, 1883, 60)
  allowed_args = ["test", "set_home_location", "land", "upload_waypoint_mission", "take_off", "start_motors",
                  "stop_motors", "shoot_photo", "load_waypoint_mission", "take_off_and_land", "stop_waypoint_mission",
                  "start_waypoint_mission", "go_home"]
  print(allowed_args)
  if sys.argv[1] == "test":
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"shoot_photo"}')
      time.sleep(1)
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"start_motors"}')
      time.sleep(3)
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"stop_motors"}')
  elif sys.argv[1] == "set_home_location":
      payload = {
          "type": "set_home_location",
          "longitude": 20.0,
          "latitude": 113.0,
      }
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload=json.dumps(payload))
  elif sys.argv[1] == "load_waypoint_mission":
      payload = {
          "type": "load_waypoint_mission",
          "finished_action": "NO_ACTION",
          "auto_flight_speed": 1.0,
          "max_flight_speed": 5.0,
          "heading_mode": "AUTO",
          "waypoints": [
              {
                  "attitude": 10,
                  "longitude": START_POINT_LONGITUDE,
                  "latitude": START_POINT_LATITUDE + ONE_METER_OFFSET * 0.5
              },
              {
                  "attitude": 11,
                  "longitude": START_POINT_LONGITUDE + ONE_METER_OFFSET * 1,
                  "latitude": START_POINT_LATITUDE - ONE_METER_OFFSET * 1
              },
              {
                  "attitude": 12,
                  "longitude": START_POINT_LONGITUDE + ONE_METER_OFFSET * 2,
                  "latitude": START_POINT_LATITUDE + ONE_METER_OFFSET * 1
              }
          ]
      }
      print(json.dumps(payload))
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload=json.dumps(payload))
  elif sys.argv[1] == "take_off_and_land":
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"take_off"}')
      time.sleep(3)
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"shoot_photo"}')
      time.sleep(3)
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"land"}')
  elif sys.argv[1] in allowed_args:
      client.publish(topic=MQTT_PATH + CLIENT_ID, payload='{"type":"' + sys.argv[1] + '"}')
  else:
      print("forbidden command " + sys.argv[1])
\end{lstlisting}
\source{Badania własne.}

\subsubsection{Subskrybowanie Topic-u przeznaczonego do przesyłania zdjęć}

Przy każdym wywołaniu polecenia zrobienia zdjęcia na BSP, po wykonaniu, jest ono przesyłane w najwyższej możliwej rozdzielczości, na dedykowany Topic. Poniższy skrypt (Kod. 20.) subskrybuje go i przy każdym otrzymaniu wiadomości zapisuje ją w folderze, w którym jest uruchomiony skrypt. Szybki podgląd zdjęcia pozwala na zweryfikowanie czy transmisja i kodowanie odbywa się prawidłowo.


\begin{lstlisting}[language=Python, caption=Skrypt nasuchujący na podanym topicu MQTT i zapisujący dane z wiadomości MQTT w formacie /text{jpeg}]
def on_connect(_client, userdata, flags, rc):
  print("Connected with result code " + str(rc))
  _client.subscribe(MQTT_PATH)


def on_message(_client, userdata, msg):
  f = open('output.jpeg', "wb")
  f.write(msg.payload)
  print("Image Received")
  f.close()

if __name__ == '__main__':
  client = mqtt.Client()
  client.username_pw_set(username=USERNAME, password=PASSWORD)
  client.on_connect = on_connect
  client.on_message = on_message
  client.connect(MQTT_SERVER, 1883, 60)
  client.loop_forever()

\end{lstlisting}
\source{Badania własne.}

\newpage
\subsection{Testy manualne}
Ostatnim przeprowadzonym testem było przesłanie ręcznie na podany Topic związany z użytym dronem DJI pojedynczych treści. W tym celu skorzystano na komputerze osobistym z linuxem z pakietu \textit{mosquitto}. Następnie sprawdzono również otrzymywane dane, przy subskrybcji odpowiedniego Topic-a. Przeprowadzone działanie potwierdziło poprawne działanie aplikacji.
W ramch testów manualnych zrealizowano następujący scenariusz (Tab. 26.).

\begin{figure}[!ht]
\begin{center}
  \includegraphics[width=15cm]{./Obrazy/exece.png}
  \caption{Zrzut ekranu prezentującego przesyłanie komend i odbieranie statusu staku powietrznego.}
  \end{center}
  \source{Badania własne.}
\end{figure}

\begin{table}[!ht]
  \begin{center}
      \begin{tabular}{|l|l|l|l|}
  \hline
  Lp. &
    Nazwa &
    \begin{tabular}[c]{@{}l@{}}Typ przesłanej komendy \\ przez MQTT\end{tabular} &
    Efekt \\ \hline
  1 &
    \begin{tabular}[c]{@{}l@{}}Uruchomienie \\ silników\end{tabular} &
    start\_motors &
    \begin{tabular}[c]{@{}l@{}}Silniki są włączone i chodzą \\ na niskich obrotach\end{tabular} \\ \hline
  2 &
    Wystartowanie &
    take\_off &
    \begin{tabular}[c]{@{}l@{}}BSP unosi sie w powietrzu na \\ wysokości około 1,4m\end{tabular} \\ \hline
  3 &
    \begin{tabular}[c]{@{}l@{}}Zrobienie \\ zdjęcia\end{tabular} &
    shoot\_photo &
    \begin{tabular}[c]{@{}l@{}}BSP przesłało do brokera MQTT \\ obraz aktualnie obserowanego \\ obszaru\end{tabular} \\ \hline
  4 &
    Wylądowanie &
    land   & \begin{tabular}[c]{@{}l@{}}BSP wylądowało i automatycznie \\ wyłączyło silniki\end{tabular} \\ \hline
  \end{tabular}
  \end{center}

  \caption{Opracowanie własne.}
\end{table}


\clearpage \section*{Podsumowanie} \addcontentsline{toc}{section}{Podsumowanie}

Głównym celem niniejszej pracy było zaprezentowanie rozwiązania umożliwiającego komunikacje między punktem centralnym kontrolującym cały rój dronów a pojedynczym bezpilotowym statkiem powietrznym. Cel ten został osiągnięty. System opiera swoją komunikację na protokole MQTT, który ma dwie główne zalety w tym kontekście: jest odporny na przerywane połączenia i umożliwia bezproblemową komunikację jeden do wielu. Obsługiwane bezpilotowe statki latające ograniczone są do tych dostarczanych przez firmę DJI, ponieważ udostępnia on również dobrze udokumentowaną bibliotekę, która umożliwia obsługę drona w zakresie umożliwiającym realizacje wszelkich stawianych mu zadań. Pomiędzy brokerem MQTT a dronem znajduje się urządzenie mobilne z systemem Android. Jest on warstwą pośrednią, której odpowiedzialnością jest kontrolowanie drona i realizowanie poleceń otrzymywanych przez dedykowany Topic MQTT.

W trakcie projektowania i implementacji korzystano z ogólnie przyjętych zasad dobrego programowania obiektowego, w tym opisanych przez Roberta C. Martina w książce "\textit{Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall.}". Efektem tego są m.in. klasy, które zgodnie z zasadą SOLID \textit{Single responsibility principle} mają odpowiednio małe odpowiedzialności, co przyczynia się do przejrzystej architektury rozwiązania i czytelnego kodu. \cite{solid}\cite{clean-code}

W trakcie pracy korzystano ze zwinnych technik programowania, szczególne z TDD (Test-driven development). Polega ona na pisaniu w pierwszej kolejności testu automatycznego testującego daną funkcjonalność, a dopiero w kolejnym kroku, kodu programu go realizującą. W przypadku, gdy programista zaczyna od pisania kodu, a dopiero potem testów automatycznych, pisze je w ten sposób, aby pokryć przypadki testowe, które sam przewidział w trakcie implementacji danej funkcjonalności. W przypadku TDD, gdy programista pisze testy przed implementacją, faktycznie podchodzi do kodu jak do "czarnej skrzynki" i bardziej prawdopodobnie jest to, że testy pokryją bardziej skrajne przypadki. Oprócz tych testów jednostkowych przeprowadzono również testy manualne i end-to-end.

Pomimo tego, że ponad 70\% rynku dronów konsumenckich należy do producenta DJI, ograniczenie obsługi BSP w systemie do wyłącznie tego producenta, stanowi największą niedoskonałość zaprezentowanego systemu. Jednak proponowany rozwój systemu nie dotyczy zainteresowania pozostałą częścią rynku, a dronami niekomercyjnymi, szczególnie działającymi w ramach otwartoźródłowego oprogramowania ArduPilot. Taka obsługa umożliwiłaby konstruowanie własnych, tańszych rozwiązań.

Drugim obszarem w którym system mógłby się rozwijać jest zwiększanie autonomiczności BSP na poziomie samego kontrolera. Można tego dokonać dzięki metodom sztucznej inteligencji, szczególnie rozpoznawania obrazowego. Przykładem wykorzystania takich metod mógłby być lot patrolowy, w którego trakcie system dokonywałby rozpoznania obrazowego, a w przypadku stwierdzenie, że rozpoznany obiekt ten stanowi szczególne zainteresowanie, śledzenia go i automatycznego powiadomienia operatora przez jednostkę centralną. W obecnym środowisku uruchomieniwoym nie jest to możliwe, ponieważ urządzenie mobilne nie jest w stanie obsłużyć tak obciążających operacji, jak rozpoznanie obrazowe.

Zaprezentowany system spełnia pokładane w nim oczekiwania przez autora i stanowi bardzo dobrą bazę do dalszego rozwoju lub wykorzystania w większych rozwiązaniach, czyli docelowym roju dronów.

% Podsumowanie powinno korespondować z tematem i założonymi celami pracy. Zaleca się, aby zawierało syntetyczne podsumowanie wyników z odniesieniem do stopnia realizacji oraz wskazaniem najważniejszych osiągnięć i słabszych stron pracy. Może również obejmować omówienie podobieństw i różnic między uzyskanymi a publikowanymi wynikami innych autorów. Ponadto, winno przedstawiać dalsze interesujące kierunki rozwoju pracy.

\clearpage \begin{thebibliography}{999}
\addcontentsline{toc}{section}{\refname}

\bibitem{usa-roj}
\bibTitle{Armia USA sprawdzi bojowy rój dronów. Ma być tani oraz rozpoznawać i atakować cele z poziomu jednego kontrolera}
\myurl{https://www.chip.pl/2022/03/armia-usa-bojowy-roj-dronow-bluehalo/} [dostęp: 29-05-2022];


\bibitem{dron-ibuk}
Sarah E. Kreps
\bibTitle{Drony. Wprowadzenie Technologie Zastosowania}
Wydawnictwo Naukowe PWN, Warszawa, 2019;

\bibitem{arton-kelsey}
A. Kelsey
\bibTitle{Flying Robots 101: Everthing You Need to Know about Drones}, 
\myurl{https://www.popsci.com/technology/article/2013-03/drone-any-other-name/} [dostęp: 20-04-2022];

\bibitem{NB-IoT_vs_Lora}
\bibTitle{NB-IoT vs Lora}
\myurl{https://ubidots.com/blog/lorawan-vs-nb-iot/\#lorawan-vs-nb-iot-a-quick-overview} [dostęp: 20-04-2022];

\bibitem{m2m-web}
\bibTitle{machine-to-machine (M2M)}
\myurl{https://www.techtarget.com/iotagenda/definition/machine-to-machine-M2M} [dostęp: 20-04-2022];

\bibitem{LPWA-wiki}
\bibTitle{LPWA wikipedia}
\myurl{https://pl.wikipedia.org/wiki/LPWAN} [dostęp: 20-04-2022];

\bibitem{LoRa-article}
\bibTitle{LoRa Technology - An Overview, IEEE, 2018}
\myurl{https://ieeexplore.ieee.org/document/8474715} [dostęp: 20-04-2022];


\bibitem{yuneec-wiki}
\bibTitle{Wikipedia: Yuneec International}
\myurl{https://en.wikipedia.org/wiki/Yuneec_International} [dostęp: 25-04-2022];

\bibitem{nbiot-article}
\bibTitle{On the Performance of Narrow-band Internet of
Things (NB-IoT) for Delay-tolerant Services, IEEE, 2019}
\myurl{https://ieeexplore.ieee.org/document/8768871} [dostęp: 20-04-2022];

\bibitem{dji-wiki}
\bibTitle{Wikipedia: SZ DJI Technology Co., Ltd.},
\myurl{https://en.wikipedia.org/wiki/DJI} [dostęp: 20-04-2022];

\bibitem{queen-bee}
\bibTitle{De Havilland DH-82 "Tiger Moth" ("Queen Bee"), 1931},
\myurl{http://www.samolotypolskie.pl/samoloty/782/126/De-Havilland-DH-82-Tiger-Moth-Queen-Bee} [dostęp: 22-04-2022];

\bibitem{dji-market-share}
\bibTitle{DJI market share: here’s exactly how rapidly it has grown in just a few years},
\myurl{https://www.thedronegirl.com/2018/09/18/dji-market-share/} [dostęp: 22404-2022];

\bibitem{fotografia-drony-ukraina}
\bibTitle{Wojna w Ukrainie: Pasjonaci dronów namierzają rosyjskie wojska},
\myurl{https://fotoblogia.pl/17711,wojna-w-ukrainie-pasjonaci-dronow-namierzaja-rosyjskie-wojska} [dostęp: 22-04-2022];

\bibitem{bayraktar-chip}
\bibTitle{Tureckie drony na Ukrainie pokazały wojnę przyszłości. Bayraktar TB2 wyrządzają ogromne szkody},
\myurl{https://www.chip.pl/2022/03/tureckie-drony-w-ukrainie-pokazaly-wojne-przyszlosci-bayraktar-tb2-wyrzadzaja-ogromne-szkody/} [dostęp: 22-04-2022];

\bibitem{bayraktar-pap}
\bibTitle{Zaskakująca skuteczność Bayraktarów. Ekspert o rosnącej roli dronów w wojnie},
\myurl{https://www.pap.pl/aktualnosci/news\%2C1129159\%2Czaskakujaca-skutecznosc-bayraktarow-ekspert-o-rosnacej-roli-dronow-w} [dostęp: 22-04-2022];

\bibitem{dji-mavic-mini-se-spec}
\bibTitle{DJI Mavic Mini SE},
\myurl{https://www.dji.com/pl/mini-se?site=brandsite&from=nav} [dostęp: 20-04-2022];

\bibitem{dji-store}
\bibTitle{DJI store},
\myurl{https://store.dji.com} [dostęp: 20-04-2022];

\bibitem{lightbridge-dji}
\bibTitle{DJI Lightbridge},
\myurl{https://www.dji.com/pl/dji-lightbridge/info} [dostęp: 20-04-2022];

\bibitem{lightbridge2-dji}
\bibTitle{DJI Lightbridge2},
\myurl{https://www.dji.com/pl/lightbridge-2/info\#specs} [dostęp: 20-04-2022];

\bibitem{OFDM-wiki}
\bibTitle{Wikipedia: OFDM},
\myurl{https://pl.wikipedia.org/wiki/OFDM} [dostęp: 20-04-2022];

\bibitem{firebee-wiki}
\bibTitle{Wikipedia: Ryan Model 147 Lightning Bug},
\myurl{https://en.wikipedia.org/wiki/Ryan_Model_147} [dostęp: 22-04-2022];

\bibitem{predator-wiki}
\bibTitle{Wikipedia: MQ-1 Predator},
\myurl{https://en.wikipedia.org/wiki/General_Atomics_MQ-1_Predator} [dostęp: 22-04-2022];

\bibitem{baykar-wiki}
\bibTitle{Wikipedia: Baykar},
\myurl{https://en.wikipedia.org/wiki/Baykar} [dostęp: 22-04-2022];

\bibitem{FHSS-wiki}
\bibTitle{Wikipedia: FHSS},
\myurl{https://pl.wikipedia.org/wiki/FHSS} [dostęp: 20-04-2022];

\bibitem{ocusync-yt}
\bibTitle{DJI Mavic 2 - Ocusync 2.0 What is it \& What's Compatible ? + How is it different from Lightbridge},
\myurl{https://www.youtube.com/watch?v=gfqcSv9sR0A} [dostęp: 20-04-2022];

\bibitem{dji-gogle}
\bibTitle{DJI Gogle},
\myurl{https://u.cyfrowe.pl/600x0/2/7/2_732250420.png} [dostęp: 20-04-2022];

\bibitem{konkurs-mon}
\bibTitle{Konkurs MON na bezzałogowe sytemy powietrzne, lądowe, morskie},
\myurl{https://www.wojsko-polskie.pl/wat/articles/aktualnosci-w/konkurs-mon-na-bezzalogowe-systemy-powietrzne-ladowe-i-morskie/} [dostęp: 21-04-2022];

\bibitem{wiki-gaas}
\bibTitle{Wikipedia: General Atomics Aeronautical Systems},
\myurl{https://en.wikipedia.org/wiki/General_Atomics_Aeronautical_Systems} [dostęp: 26-04-2022];

\bibitem{gd-about}
\bibTitle{General Dynamics: Our history},
\myurl{https://www.gd.com/about-gd/our-history} [dostęp: 26-04-2022];

\bibitem{pansa-lot-medyczny}
\bibTitle{PANSA: Ruszają regularne loty transportowe BSP},
\myurl{https://www.pansa.pl/ruszaja-regularne-loty-transportowe-bsp/} [dostęp: 28-04-2022];

\bibitem{topr-dron}
\bibTitle{Akcja TOPR dron dostarczył koce i ogrzewacze},
\myurl{http://www.swiatdronow.pl/akcja-topr-dron-dostarczyl-koce-i-ogrzewacze/} [dostęp: 28-04-2022];

\bibitem{snowbrains-drone}
\bibTitle{Drones to the Rescue? How Drones are Changing the Landscape of High Mountain Rescue Efforts},
\myurl{https://snowbrains.com/drones-to-the-rescue-how-drones-are-changing-the-landscape-of-high-mountain-rescue-efforts/} [dostęp: 29-04-2022];

\bibitem{bbc-drone-rescue}
\bibTitle{Drones guide rescuers to hunter lost in North Carolina woods, officials say},
\myurl{https://www.newsobserver.com/news/state/north-carolina/article260714992.html/} [dostęp: 29-04-2022]; 

\bibitem{dron-lawa-pogoda}
\bibTitle{Wleciał dronem do wnętrza wulkanu na Islandii. Ostatnie sekundy nagrania jeżą włosy na głowie [WIDEO]},
\myurl{https://www.twojapogoda.pl/wiadomosc/2021-06-02/wlecial-dronem-do-wnetrza-wulkanu-na-islandii-ostatnie-sekundy-nagrania-jeza-wlosy-na-glowie-wideo/} [dostęp: 29-04-2022]; 

\bibitem{washingtonpost-drone-movie}
\bibTitle{It’s a bird! It’s a plane! It’s a drone that makes movies!},
\myurl{https://www.washingtonpost.com/news/the-switch/wp/2013/08/15/its-a-bird-its-a-plane-its-a-drone-that-makes-movies/} [dostęp: 29-04-2022]; 

\bibitem{how-to-build-drone}
\bibTitle{How to Build a Drone: Construct Your Drone from Scratch},
\myurl{https://www.mydronelab.com/blog/how-to-build-a-drone.html} [dostęp: 29-04-2022]; 

\bibitem{drone-transport}
\bibTitle{Drone Delivery Was Supposed to be the Future. What Went Wrong?},
\myurl{https://www.youtube.com/watch?v=J-M98KLgaUU} [dostęp: 29-04-2022]; 

\bibitem{sosnowiec-drone}
\bibTitle{Drony przetransportują sprzęt medyczny nad Sosnowcem. Przed nami spotkanie z mieszkańcami},
\myurl{https://sosnowiec.naszemiasto.pl/drony-przetransportuja-sprzet-medyczny-nad-sosnowcem-przed/ar/c1-8493233} [dostęp: 29-04-2022]; 

\bibitem{solid}
\bibTitle{SOLID czyli dobre praktyki w programowaniu obiektowym},
\myurl{https://www.samouczekprogramisty.pl/solid-czyli-dobre-praktyki-w-programowaniu-obiektowym/} [dostęp: 20-05-2022]; 

\bibitem{clean-code}
Robert C. Martin
\bibTitle{Clean Code: A Handbook of Agile Software Craftsmanship}
Financial Times Prentice Hall, Upper Saddle River, NJ, 2008;




\end{thebibliography}

\clearpage

\listoffigures
\addcontentsline{toc}{section}{Spis rysunków}

\newpage
\listoftables
\addcontentsline{toc}{section}{Spis tabel}

\clearpage \section*{Załączniki}
\addcontentsline{toc}{section}{Załączniki}
\begin{enumerate}
    \item Płyta CD/DVD zawierająca:
    \begin{enumerate}
        \item Prezentację wyników pracy dyplomowej
        \item Kody źródłowe oprogramowania
        \item Biblioteki programowe niezbędne do zbudowania i uruchomienia oprogramowania
    \end{enumerate}
\end{enumerate}

\end{document}